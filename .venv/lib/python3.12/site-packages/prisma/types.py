# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template types.py.jinja --
from typing import TypeVar

import httpx
from . import _types
from .utils import _NoneType



# TODO: filters with aggregates should have their own recursive fields
# TODO: cleanup whitespace control
# TODO: add an argument to signify that the last iteration should be skipped


SortMode = _types.SortMode
SortOrder = _types.SortOrder

MetricsFormat = _types.MetricsFormat

DatasourceOverride = _types.DatasourceOverride
HttpConfig = _types.HttpConfig


# types that can be serialized to json by our query builder
Serializable = Union[
    None,
    bool,
    float,
    int,
    str,
    datetime.datetime,
    List[Any],
    Dict[None, Any],
    Dict[bool, Any],
    Dict[float, Any],
    Dict[int, Any],
    Dict[str, Any],
]


    

StringFilter = TypedDict(
    'StringFilter',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive1'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)


StringFilterRecursive1 = TypedDict(
    'StringFilterRecursive1',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive2'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)


StringFilterRecursive2 = TypedDict(
    'StringFilterRecursive2',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive3'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)


StringFilterRecursive3 = TypedDict(
    'StringFilterRecursive3',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive4'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)


StringFilterRecursive4 = TypedDict(
    'StringFilterRecursive4',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
                'mode': SortMode,
        'search': str,
    },
    total=False,
)


class StringWithAggregatesFilter(StringFilter, total=False):
    _max: 'StringFilter'
    _min: 'StringFilter'
    _sum: 'StringFilter'
    _avg: 'StringFilter'
    _count: 'IntFilter'


    

DateTimeFilter = TypedDict(
    'DateTimeFilter',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive1'],
    },
    total=False,
)


DateTimeFilterRecursive1 = TypedDict(
    'DateTimeFilterRecursive1',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive2'],
    },
    total=False,
)


DateTimeFilterRecursive2 = TypedDict(
    'DateTimeFilterRecursive2',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive3'],
    },
    total=False,
)


DateTimeFilterRecursive3 = TypedDict(
    'DateTimeFilterRecursive3',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive4'],
    },
    total=False,
)


DateTimeFilterRecursive4 = TypedDict(
    'DateTimeFilterRecursive4',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
            },
    total=False,
)


class DateTimeWithAggregatesFilter(DateTimeFilter, total=False):
    _max: 'DateTimeFilter'
    _min: 'DateTimeFilter'
    _sum: 'DateTimeFilter'
    _avg: 'DateTimeFilter'
    _count: 'IntFilter'


    

BooleanFilter = TypedDict(
    'BooleanFilter',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive1'],
    },
    total=False,
)


BooleanFilterRecursive1 = TypedDict(
    'BooleanFilterRecursive1',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive2'],
    },
    total=False,
)


BooleanFilterRecursive2 = TypedDict(
    'BooleanFilterRecursive2',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive3'],
    },
    total=False,
)


BooleanFilterRecursive3 = TypedDict(
    'BooleanFilterRecursive3',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive4'],
    },
    total=False,
)


BooleanFilterRecursive4 = TypedDict(
    'BooleanFilterRecursive4',
    {
        'equals': bool,
            },
    total=False,
)


class BooleanWithAggregatesFilter(BooleanFilter, total=False):
    _max: 'BooleanFilter'
    _min: 'BooleanFilter'
    _sum: 'BooleanFilter'
    _avg: 'BooleanFilter'
    _count: 'IntFilter'


    

IntFilter = TypedDict(
    'IntFilter',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive1'],
    },
    total=False,
)


IntFilterRecursive1 = TypedDict(
    'IntFilterRecursive1',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive2'],
    },
    total=False,
)


IntFilterRecursive2 = TypedDict(
    'IntFilterRecursive2',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive3'],
    },
    total=False,
)


IntFilterRecursive3 = TypedDict(
    'IntFilterRecursive3',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive4'],
    },
    total=False,
)


IntFilterRecursive4 = TypedDict(
    'IntFilterRecursive4',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
            },
    total=False,
)


class IntWithAggregatesFilter(IntFilter, total=False):
    _max: 'IntFilter'
    _min: 'IntFilter'
    _sum: 'IntFilter'
    _avg: 'IntFilter'
    _count: 'IntFilter'


BigIntFilter = IntFilter
BigIntWithAggregatesFilter = IntWithAggregatesFilter
    

FloatFilter = TypedDict(
    'FloatFilter',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive1'],
    },
    total=False,
)


FloatFilterRecursive1 = TypedDict(
    'FloatFilterRecursive1',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive2'],
    },
    total=False,
)


FloatFilterRecursive2 = TypedDict(
    'FloatFilterRecursive2',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive3'],
    },
    total=False,
)


FloatFilterRecursive3 = TypedDict(
    'FloatFilterRecursive3',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive4'],
    },
    total=False,
)


FloatFilterRecursive4 = TypedDict(
    'FloatFilterRecursive4',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
            },
    total=False,
)


class FloatWithAggregatesFilter(FloatFilter, total=False):
    _max: 'FloatFilter'
    _min: 'FloatFilter'
    _sum: 'FloatFilter'
    _avg: 'FloatFilter'
    _count: 'IntFilter'


    

BytesFilter = TypedDict(
    'BytesFilter',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive1'],
    },
    total=False,
)


BytesFilterRecursive1 = TypedDict(
    'BytesFilterRecursive1',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive2'],
    },
    total=False,
)


BytesFilterRecursive2 = TypedDict(
    'BytesFilterRecursive2',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive3'],
    },
    total=False,
)


BytesFilterRecursive3 = TypedDict(
    'BytesFilterRecursive3',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive4'],
    },
    total=False,
)


BytesFilterRecursive4 = TypedDict(
    'BytesFilterRecursive4',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
            },
    total=False,
)


class BytesWithAggregatesFilter(BytesFilter, total=False):
    _max: 'BytesFilter'
    _min: 'BytesFilter'
    _sum: 'BytesFilter'
    _avg: 'BytesFilter'
    _count: 'IntFilter'


# TODO: preview feature for improving JSON filtering
JsonFilter = TypedDict(
    'JsonFilter',
    {
        'equals': 'fields.Json',
        'not': 'fields.Json',
    },
    total=False,
)


class JsonWithAggregatesFilter(JsonFilter, total=False):
    _max: 'JsonFilter'
    _min: 'JsonFilter'
    _sum: 'JsonFilter'
    _avg: 'JsonFilter'
    _count: 'IntFilter'


    

DecimalFilter = TypedDict(
    'DecimalFilter',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive1'],
    },
    total=False,
)


DecimalFilterRecursive1 = TypedDict(
    'DecimalFilterRecursive1',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive2'],
    },
    total=False,
)


DecimalFilterRecursive2 = TypedDict(
    'DecimalFilterRecursive2',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive3'],
    },
    total=False,
)


DecimalFilterRecursive3 = TypedDict(
    'DecimalFilterRecursive3',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive4'],
    },
    total=False,
)


DecimalFilterRecursive4 = TypedDict(
    'DecimalFilterRecursive4',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
            },
    total=False,
)


class DecimalWithAggregatesFilter(StringFilter, total=False):
    _max: 'DecimalFilter'
    _min: 'DecimalFilter'
    _sum: 'DecimalFilter'
    _avg: 'DecimalFilter'
    _count: 'IntFilter'


class _FloatSetInput(TypedDict):
    set: float


class _FloatDivideInput(TypedDict):
    divide: float


class _FloatMultiplyInput(TypedDict):
    multiply: float


class _FloatIncrementInput(TypedDict):
    increment: float


class _FloatDecrementInput(TypedDict):
    decrement: float


class _IntSetInput(TypedDict):
    set: int


class _IntDivideInput(TypedDict):
    divide: int


class _IntMultiplyInput(TypedDict):
    multiply: int


class _IntIncrementInput(TypedDict):
    increment: int


class _IntDecrementInput(TypedDict):
    decrement: int


AtomicFloatInput = Union[
    _FloatSetInput,
    _FloatDivideInput,
    _FloatMultiplyInput,
    _FloatIncrementInput,
    _FloatDecrementInput,
]
AtomicIntInput = Union[
    _IntSetInput,
    _IntDivideInput,
    _IntMultiplyInput,
    _IntIncrementInput,
    _IntDecrementInput,
]
AtomicBigIntInput = AtomicIntInput

class _StringListFilterEqualsInput(TypedDict):
    equals: Optional[List[_str]]


class _StringListFilterHasInput(TypedDict):
    has: _str


class _StringListFilterHasEveryInput(TypedDict):
    has_every: List[_str]


class _StringListFilterHasSomeInput(TypedDict):
    has_some: List[_str]


class _StringListFilterIsEmptyInput(TypedDict):
    is_empty: bool


StringListFilter = Union[
    _StringListFilterHasInput,
    _StringListFilterEqualsInput,
    _StringListFilterHasSomeInput,
    _StringListFilterIsEmptyInput,
    _StringListFilterHasEveryInput,
]


class _StringListUpdateSet(TypedDict):
    set: List[_str]


class _StringListUpdatePush(TypedDict):
    push: List[_str]


StringListUpdate = Union[
    List[_str],
    _StringListUpdateSet,
    _StringListUpdatePush,
]

class _BytesListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Base64']]


class _BytesListFilterHasInput(TypedDict):
    has: 'fields.Base64'


class _BytesListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Base64']


class _BytesListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Base64']


class _BytesListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BytesListFilter = Union[
    _BytesListFilterHasInput,
    _BytesListFilterEqualsInput,
    _BytesListFilterHasSomeInput,
    _BytesListFilterIsEmptyInput,
    _BytesListFilterHasEveryInput,
]


class _BytesListUpdateSet(TypedDict):
    set: List['fields.Base64']


class _BytesListUpdatePush(TypedDict):
    push: List['fields.Base64']


BytesListUpdate = Union[
    List['fields.Base64'],
    _BytesListUpdateSet,
    _BytesListUpdatePush,
]

class _DateTimeListFilterEqualsInput(TypedDict):
    equals: Optional[List[datetime.datetime]]


class _DateTimeListFilterHasInput(TypedDict):
    has: datetime.datetime


class _DateTimeListFilterHasEveryInput(TypedDict):
    has_every: List[datetime.datetime]


class _DateTimeListFilterHasSomeInput(TypedDict):
    has_some: List[datetime.datetime]


class _DateTimeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DateTimeListFilter = Union[
    _DateTimeListFilterHasInput,
    _DateTimeListFilterEqualsInput,
    _DateTimeListFilterHasSomeInput,
    _DateTimeListFilterIsEmptyInput,
    _DateTimeListFilterHasEveryInput,
]


class _DateTimeListUpdateSet(TypedDict):
    set: List[datetime.datetime]


class _DateTimeListUpdatePush(TypedDict):
    push: List[datetime.datetime]


DateTimeListUpdate = Union[
    List[datetime.datetime],
    _DateTimeListUpdateSet,
    _DateTimeListUpdatePush,
]

class _BooleanListFilterEqualsInput(TypedDict):
    equals: Optional[List[_bool]]


class _BooleanListFilterHasInput(TypedDict):
    has: _bool


class _BooleanListFilterHasEveryInput(TypedDict):
    has_every: List[_bool]


class _BooleanListFilterHasSomeInput(TypedDict):
    has_some: List[_bool]


class _BooleanListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BooleanListFilter = Union[
    _BooleanListFilterHasInput,
    _BooleanListFilterEqualsInput,
    _BooleanListFilterHasSomeInput,
    _BooleanListFilterIsEmptyInput,
    _BooleanListFilterHasEveryInput,
]


class _BooleanListUpdateSet(TypedDict):
    set: List[_bool]


class _BooleanListUpdatePush(TypedDict):
    push: List[_bool]


BooleanListUpdate = Union[
    List[_bool],
    _BooleanListUpdateSet,
    _BooleanListUpdatePush,
]

class _IntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _IntListFilterHasInput(TypedDict):
    has: _int


class _IntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _IntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _IntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


IntListFilter = Union[
    _IntListFilterHasInput,
    _IntListFilterEqualsInput,
    _IntListFilterHasSomeInput,
    _IntListFilterIsEmptyInput,
    _IntListFilterHasEveryInput,
]


class _IntListUpdateSet(TypedDict):
    set: List[_int]


class _IntListUpdatePush(TypedDict):
    push: List[_int]


IntListUpdate = Union[
    List[_int],
    _IntListUpdateSet,
    _IntListUpdatePush,
]

class _BigIntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _BigIntListFilterHasInput(TypedDict):
    has: _int


class _BigIntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _BigIntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _BigIntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BigIntListFilter = Union[
    _BigIntListFilterHasInput,
    _BigIntListFilterEqualsInput,
    _BigIntListFilterHasSomeInput,
    _BigIntListFilterIsEmptyInput,
    _BigIntListFilterHasEveryInput,
]


class _BigIntListUpdateSet(TypedDict):
    set: List[_int]


class _BigIntListUpdatePush(TypedDict):
    push: List[_int]


BigIntListUpdate = Union[
    List[_int],
    _BigIntListUpdateSet,
    _BigIntListUpdatePush,
]

class _FloatListFilterEqualsInput(TypedDict):
    equals: Optional[List[_float]]


class _FloatListFilterHasInput(TypedDict):
    has: _float


class _FloatListFilterHasEveryInput(TypedDict):
    has_every: List[_float]


class _FloatListFilterHasSomeInput(TypedDict):
    has_some: List[_float]


class _FloatListFilterIsEmptyInput(TypedDict):
    is_empty: bool


FloatListFilter = Union[
    _FloatListFilterHasInput,
    _FloatListFilterEqualsInput,
    _FloatListFilterHasSomeInput,
    _FloatListFilterIsEmptyInput,
    _FloatListFilterHasEveryInput,
]


class _FloatListUpdateSet(TypedDict):
    set: List[_float]


class _FloatListUpdatePush(TypedDict):
    push: List[_float]


FloatListUpdate = Union[
    List[_float],
    _FloatListUpdateSet,
    _FloatListUpdatePush,
]

class _JsonListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Json']]


class _JsonListFilterHasInput(TypedDict):
    has: 'fields.Json'


class _JsonListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Json']


class _JsonListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Json']


class _JsonListFilterIsEmptyInput(TypedDict):
    is_empty: bool


JsonListFilter = Union[
    _JsonListFilterHasInput,
    _JsonListFilterEqualsInput,
    _JsonListFilterHasSomeInput,
    _JsonListFilterIsEmptyInput,
    _JsonListFilterHasEveryInput,
]


class _JsonListUpdateSet(TypedDict):
    set: List['fields.Json']


class _JsonListUpdatePush(TypedDict):
    push: List['fields.Json']


JsonListUpdate = Union[
    List['fields.Json'],
    _JsonListUpdateSet,
    _JsonListUpdatePush,
]

class _DecimalListFilterEqualsInput(TypedDict):
    equals: Optional[List[decimal.Decimal]]


class _DecimalListFilterHasInput(TypedDict):
    has: decimal.Decimal


class _DecimalListFilterHasEveryInput(TypedDict):
    has_every: List[decimal.Decimal]


class _DecimalListFilterHasSomeInput(TypedDict):
    has_some: List[decimal.Decimal]


class _DecimalListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DecimalListFilter = Union[
    _DecimalListFilterHasInput,
    _DecimalListFilterEqualsInput,
    _DecimalListFilterHasSomeInput,
    _DecimalListFilterIsEmptyInput,
    _DecimalListFilterHasEveryInput,
]


class _DecimalListUpdateSet(TypedDict):
    set: List[decimal.Decimal]


class _DecimalListUpdatePush(TypedDict):
    push: List[decimal.Decimal]


DecimalListUpdate = Union[
    List[decimal.Decimal],
    _DecimalListUpdateSet,
    _DecimalListUpdatePush,
]


# user types

class userOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the user create method"""
    id: _int
    role: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    articles: 'articleCreateManyNestedWithoutRelationsInput'
    comments: 'commentCreateManyNestedWithoutRelationsInput'
    likes: 'likeCreateManyNestedWithoutRelationsInput'


class userCreateInput(userOptionalCreateInput):
    """Required arguments to the user create method"""
    username: _str
    email: _str
    hashedpassword: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class userOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the user create method, without relations"""
    id: _int
    role: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime


class userCreateWithoutRelationsInput(userOptionalCreateWithoutRelationsInput):
    """Required arguments to the user create method, without relations"""
    username: _str
    email: _str
    hashedpassword: _str

class userConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'userCreateWithoutRelationsInput'
    where: 'userWhereUniqueInput'

class userCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'userCreateWithoutRelationsInput'
    connect: 'userWhereUniqueInput'
    connect_or_create: 'userConnectOrCreateWithoutRelationsInput'


class userCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['userCreateWithoutRelationsInput', List['userCreateWithoutRelationsInput']]
    connect: Union['userWhereUniqueInput', List['userWhereUniqueInput']]
    connect_or_create: Union['userConnectOrCreateWithoutRelationsInput', List['userConnectOrCreateWithoutRelationsInput']]

_userWhereUnique_id_Input = TypedDict(
    '_userWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

_userWhereUnique_email_Input = TypedDict(
    '_userWhereUnique_email_Input',
    {
        'email': '_str',
    },
    total=True
)

userWhereUniqueInput = Union[
    '_userWhereUnique_id_Input',
    '_userWhereUnique_email_Input',
]


class userUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    username: _str
    email: _str
    hashedpassword: _str
    role: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    articles: 'articleUpdateManyWithoutRelationsInput'
    comments: 'commentUpdateManyWithoutRelationsInput'
    likes: 'likeUpdateManyWithoutRelationsInput'


class userUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    username: _str
    email: _str
    hashedpassword: _str
    role: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime


class userUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['userCreateWithoutRelationsInput']
    connect: List['userWhereUniqueInput']
    connect_or_create: List['userConnectOrCreateWithoutRelationsInput']
    set: List['userWhereUniqueInput']
    disconnect: List['userWhereUniqueInput']
    delete: List['userWhereUniqueInput']

    # TODO
    # update: List['userUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['userUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['userScalarWhereInput']
    # upsert: List['userUpserteWithWhereUniqueWithoutRelationsInput']


class userUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'userCreateWithoutRelationsInput'
    connect: 'userWhereUniqueInput'
    connect_or_create: 'userConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'userUpdateInput'
    # upsert: 'userUpsertWithoutRelationsInput'


class userUpsertInput(TypedDict):
    create: 'userCreateInput'
    update: 'userUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_user_id_OrderByInput = TypedDict(
    '_user_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_user_username_OrderByInput = TypedDict(
    '_user_username_OrderByInput',
    {
        'username': 'SortOrder',
    },
    total=True
)

_user_email_OrderByInput = TypedDict(
    '_user_email_OrderByInput',
    {
        'email': 'SortOrder',
    },
    total=True
)

_user_hashedpassword_OrderByInput = TypedDict(
    '_user_hashedpassword_OrderByInput',
    {
        'hashedpassword': 'SortOrder',
    },
    total=True
)

_user_role_OrderByInput = TypedDict(
    '_user_role_OrderByInput',
    {
        'role': 'SortOrder',
    },
    total=True
)

_user_created_at_OrderByInput = TypedDict(
    '_user_created_at_OrderByInput',
    {
        'created_at': 'SortOrder',
    },
    total=True
)

_user_updated_at_OrderByInput = TypedDict(
    '_user_updated_at_OrderByInput',
    {
        'updated_at': 'SortOrder',
    },
    total=True
)

_user_RelevanceInner = TypedDict(
    '_user_RelevanceInner',
    {
        'fields': 'List[userScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_user_RelevanceOrderByInput = TypedDict(
    '_user_RelevanceOrderByInput',
    {
        '_relevance': '_user_RelevanceInner',
    },
    total=True
)

userOrderByInput = Union[
    '_user_id_OrderByInput',
    '_user_username_OrderByInput',
    '_user_email_OrderByInput',
    '_user_hashedpassword_OrderByInput',
    '_user_role_OrderByInput',
    '_user_created_at_OrderByInput',
    '_user_updated_at_OrderByInput',
    '_user_RelevanceOrderByInput',
]



# recursive user types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

userRelationFilter = TypedDict(
    'userRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class userListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class userInclude(TypedDict, total=False):
    """user relational arguments"""
    articles: Union[bool, 'FindManyarticleArgsFromuser']
    comments: Union[bool, 'FindManycommentArgsFromuser']
    likes: Union[bool, 'FindManylikeArgsFromuser']


    

class userIncludeFromuser(TypedDict, total=False):
    """Relational arguments for user"""
    articles: Union[bool, 'FindManyarticleArgsFromuserRecursive1']
    comments: Union[bool, 'FindManycommentArgsFromuserRecursive1']
    likes: Union[bool, 'FindManylikeArgsFromuserRecursive1']


class userIncludeFromuserRecursive1(TypedDict, total=False):
    """Relational arguments for user"""
    articles: Union[bool, 'FindManyarticleArgsFromuserRecursive2']
    comments: Union[bool, 'FindManycommentArgsFromuserRecursive2']
    likes: Union[bool, 'FindManylikeArgsFromuserRecursive2']


class userIncludeFromuserRecursive2(TypedDict, total=False):
    """Relational arguments for user"""
    articles: Union[bool, 'FindManyarticleArgsFromuserRecursive3']
    comments: Union[bool, 'FindManycommentArgsFromuserRecursive3']
    likes: Union[bool, 'FindManylikeArgsFromuserRecursive3']


class userIncludeFromuserRecursive3(TypedDict, total=False):
    """Relational arguments for user"""
    articles: Union[bool, 'FindManyarticleArgsFromuserRecursive4']
    comments: Union[bool, 'FindManycommentArgsFromuserRecursive4']
    likes: Union[bool, 'FindManylikeArgsFromuserRecursive4']


class userIncludeFromuserRecursive4(TypedDict, total=False):
    """Relational arguments for user"""

    

class userArgsFromuser(TypedDict, total=False):
    """Arguments for user"""
    include: 'userIncludeFromuserRecursive1'


class userArgsFromuserRecursive1(TypedDict, total=False):
    """Arguments for user"""
    include: 'userIncludeFromuserRecursive2'


class userArgsFromuserRecursive2(TypedDict, total=False):
    """Arguments for user"""
    include: 'userIncludeFromuserRecursive3'


class userArgsFromuserRecursive3(TypedDict, total=False):
    """Arguments for user"""
    include: 'userIncludeFromuserRecursive4'


class userArgsFromuserRecursive4(TypedDict, total=False):
    """Arguments for user"""
    
    

class FindManyuserArgsFromuser(TypedDict, total=False):
    """Arguments for user"""
    take: int
    skip: int
    order_by: Union['userOrderByInput', List['userOrderByInput']]
    where: 'userWhereInput'
    cursor: 'userWhereUniqueInput'
    distinct: List['userScalarFieldKeys']
    include: 'userIncludeFromuserRecursive1'


class FindManyuserArgsFromuserRecursive1(TypedDict, total=False):
    """Arguments for user"""
    take: int
    skip: int
    order_by: Union['userOrderByInput', List['userOrderByInput']]
    where: 'userWhereInput'
    cursor: 'userWhereUniqueInput'
    distinct: List['userScalarFieldKeys']
    include: 'userIncludeFromuserRecursive2'


class FindManyuserArgsFromuserRecursive2(TypedDict, total=False):
    """Arguments for user"""
    take: int
    skip: int
    order_by: Union['userOrderByInput', List['userOrderByInput']]
    where: 'userWhereInput'
    cursor: 'userWhereUniqueInput'
    distinct: List['userScalarFieldKeys']
    include: 'userIncludeFromuserRecursive3'


class FindManyuserArgsFromuserRecursive3(TypedDict, total=False):
    """Arguments for user"""
    take: int
    skip: int
    order_by: Union['userOrderByInput', List['userOrderByInput']]
    where: 'userWhereInput'
    cursor: 'userWhereUniqueInput'
    distinct: List['userScalarFieldKeys']
    include: 'userIncludeFromuserRecursive4'


class FindManyuserArgsFromuserRecursive4(TypedDict, total=False):
    """Arguments for user"""
    take: int
    skip: int
    order_by: Union['userOrderByInput', List['userOrderByInput']]
    where: 'userWhereInput'
    cursor: 'userWhereUniqueInput'
    distinct: List['userScalarFieldKeys']
    
    

class articleIncludeFromuser(TypedDict, total=False):
    """Relational arguments for user"""
    user: Union[bool, 'userArgsFromuserRecursive1']
    comments: Union[bool, 'FindManycommentArgsFromuserRecursive1']
    likes: Union[bool, 'FindManylikeArgsFromuserRecursive1']
    categories: Union[bool, 'FindManycategory_to_articleArgsFromuserRecursive1']
    files: Union[bool, 'FindManyfileArgsFromuserRecursive1']


class articleIncludeFromuserRecursive1(TypedDict, total=False):
    """Relational arguments for user"""
    user: Union[bool, 'userArgsFromuserRecursive2']
    comments: Union[bool, 'FindManycommentArgsFromuserRecursive2']
    likes: Union[bool, 'FindManylikeArgsFromuserRecursive2']
    categories: Union[bool, 'FindManycategory_to_articleArgsFromuserRecursive2']
    files: Union[bool, 'FindManyfileArgsFromuserRecursive2']


class articleIncludeFromuserRecursive2(TypedDict, total=False):
    """Relational arguments for user"""
    user: Union[bool, 'userArgsFromuserRecursive3']
    comments: Union[bool, 'FindManycommentArgsFromuserRecursive3']
    likes: Union[bool, 'FindManylikeArgsFromuserRecursive3']
    categories: Union[bool, 'FindManycategory_to_articleArgsFromuserRecursive3']
    files: Union[bool, 'FindManyfileArgsFromuserRecursive3']


class articleIncludeFromuserRecursive3(TypedDict, total=False):
    """Relational arguments for user"""
    user: Union[bool, 'userArgsFromuserRecursive4']
    comments: Union[bool, 'FindManycommentArgsFromuserRecursive4']
    likes: Union[bool, 'FindManylikeArgsFromuserRecursive4']
    categories: Union[bool, 'FindManycategory_to_articleArgsFromuserRecursive4']
    files: Union[bool, 'FindManyfileArgsFromuserRecursive4']


class articleIncludeFromuserRecursive4(TypedDict, total=False):
    """Relational arguments for user"""

    

class articleArgsFromuser(TypedDict, total=False):
    """Arguments for user"""
    include: 'articleIncludeFromarticleRecursive1'


class articleArgsFromuserRecursive1(TypedDict, total=False):
    """Arguments for user"""
    include: 'articleIncludeFromarticleRecursive2'


class articleArgsFromuserRecursive2(TypedDict, total=False):
    """Arguments for user"""
    include: 'articleIncludeFromarticleRecursive3'


class articleArgsFromuserRecursive3(TypedDict, total=False):
    """Arguments for user"""
    include: 'articleIncludeFromarticleRecursive4'


class articleArgsFromuserRecursive4(TypedDict, total=False):
    """Arguments for user"""
    
    

class FindManyarticleArgsFromuser(TypedDict, total=False):
    """Arguments for user"""
    take: int
    skip: int
    order_by: Union['articleOrderByInput', List['articleOrderByInput']]
    where: 'articleWhereInput'
    cursor: 'articleWhereUniqueInput'
    distinct: List['articleScalarFieldKeys']
    include: 'articleIncludeFromarticleRecursive1'


class FindManyarticleArgsFromuserRecursive1(TypedDict, total=False):
    """Arguments for user"""
    take: int
    skip: int
    order_by: Union['articleOrderByInput', List['articleOrderByInput']]
    where: 'articleWhereInput'
    cursor: 'articleWhereUniqueInput'
    distinct: List['articleScalarFieldKeys']
    include: 'articleIncludeFromarticleRecursive2'


class FindManyarticleArgsFromuserRecursive2(TypedDict, total=False):
    """Arguments for user"""
    take: int
    skip: int
    order_by: Union['articleOrderByInput', List['articleOrderByInput']]
    where: 'articleWhereInput'
    cursor: 'articleWhereUniqueInput'
    distinct: List['articleScalarFieldKeys']
    include: 'articleIncludeFromarticleRecursive3'


class FindManyarticleArgsFromuserRecursive3(TypedDict, total=False):
    """Arguments for user"""
    take: int
    skip: int
    order_by: Union['articleOrderByInput', List['articleOrderByInput']]
    where: 'articleWhereInput'
    cursor: 'articleWhereUniqueInput'
    distinct: List['articleScalarFieldKeys']
    include: 'articleIncludeFromarticleRecursive4'


class FindManyarticleArgsFromuserRecursive4(TypedDict, total=False):
    """Arguments for user"""
    take: int
    skip: int
    order_by: Union['articleOrderByInput', List['articleOrderByInput']]
    where: 'articleWhereInput'
    cursor: 'articleWhereUniqueInput'
    distinct: List['articleScalarFieldKeys']
    
    

class categoryIncludeFromuser(TypedDict, total=False):
    """Relational arguments for user"""
    articles: Union[bool, 'FindManycategory_to_articleArgsFromuserRecursive1']


class categoryIncludeFromuserRecursive1(TypedDict, total=False):
    """Relational arguments for user"""
    articles: Union[bool, 'FindManycategory_to_articleArgsFromuserRecursive2']


class categoryIncludeFromuserRecursive2(TypedDict, total=False):
    """Relational arguments for user"""
    articles: Union[bool, 'FindManycategory_to_articleArgsFromuserRecursive3']


class categoryIncludeFromuserRecursive3(TypedDict, total=False):
    """Relational arguments for user"""
    articles: Union[bool, 'FindManycategory_to_articleArgsFromuserRecursive4']


class categoryIncludeFromuserRecursive4(TypedDict, total=False):
    """Relational arguments for user"""

    

class categoryArgsFromuser(TypedDict, total=False):
    """Arguments for user"""
    include: 'categoryIncludeFromcategoryRecursive1'


class categoryArgsFromuserRecursive1(TypedDict, total=False):
    """Arguments for user"""
    include: 'categoryIncludeFromcategoryRecursive2'


class categoryArgsFromuserRecursive2(TypedDict, total=False):
    """Arguments for user"""
    include: 'categoryIncludeFromcategoryRecursive3'


class categoryArgsFromuserRecursive3(TypedDict, total=False):
    """Arguments for user"""
    include: 'categoryIncludeFromcategoryRecursive4'


class categoryArgsFromuserRecursive4(TypedDict, total=False):
    """Arguments for user"""
    
    

class FindManycategoryArgsFromuser(TypedDict, total=False):
    """Arguments for user"""
    take: int
    skip: int
    order_by: Union['categoryOrderByInput', List['categoryOrderByInput']]
    where: 'categoryWhereInput'
    cursor: 'categoryWhereUniqueInput'
    distinct: List['categoryScalarFieldKeys']
    include: 'categoryIncludeFromcategoryRecursive1'


class FindManycategoryArgsFromuserRecursive1(TypedDict, total=False):
    """Arguments for user"""
    take: int
    skip: int
    order_by: Union['categoryOrderByInput', List['categoryOrderByInput']]
    where: 'categoryWhereInput'
    cursor: 'categoryWhereUniqueInput'
    distinct: List['categoryScalarFieldKeys']
    include: 'categoryIncludeFromcategoryRecursive2'


class FindManycategoryArgsFromuserRecursive2(TypedDict, total=False):
    """Arguments for user"""
    take: int
    skip: int
    order_by: Union['categoryOrderByInput', List['categoryOrderByInput']]
    where: 'categoryWhereInput'
    cursor: 'categoryWhereUniqueInput'
    distinct: List['categoryScalarFieldKeys']
    include: 'categoryIncludeFromcategoryRecursive3'


class FindManycategoryArgsFromuserRecursive3(TypedDict, total=False):
    """Arguments for user"""
    take: int
    skip: int
    order_by: Union['categoryOrderByInput', List['categoryOrderByInput']]
    where: 'categoryWhereInput'
    cursor: 'categoryWhereUniqueInput'
    distinct: List['categoryScalarFieldKeys']
    include: 'categoryIncludeFromcategoryRecursive4'


class FindManycategoryArgsFromuserRecursive4(TypedDict, total=False):
    """Arguments for user"""
    take: int
    skip: int
    order_by: Union['categoryOrderByInput', List['categoryOrderByInput']]
    where: 'categoryWhereInput'
    cursor: 'categoryWhereUniqueInput'
    distinct: List['categoryScalarFieldKeys']
    
    

class category_to_articleIncludeFromuser(TypedDict, total=False):
    """Relational arguments for user"""
    article: Union[bool, 'articleArgsFromuserRecursive1']
    category: Union[bool, 'categoryArgsFromuserRecursive1']


class category_to_articleIncludeFromuserRecursive1(TypedDict, total=False):
    """Relational arguments for user"""
    article: Union[bool, 'articleArgsFromuserRecursive2']
    category: Union[bool, 'categoryArgsFromuserRecursive2']


class category_to_articleIncludeFromuserRecursive2(TypedDict, total=False):
    """Relational arguments for user"""
    article: Union[bool, 'articleArgsFromuserRecursive3']
    category: Union[bool, 'categoryArgsFromuserRecursive3']


class category_to_articleIncludeFromuserRecursive3(TypedDict, total=False):
    """Relational arguments for user"""
    article: Union[bool, 'articleArgsFromuserRecursive4']
    category: Union[bool, 'categoryArgsFromuserRecursive4']


class category_to_articleIncludeFromuserRecursive4(TypedDict, total=False):
    """Relational arguments for user"""

    

class category_to_articleArgsFromuser(TypedDict, total=False):
    """Arguments for user"""
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive1'


class category_to_articleArgsFromuserRecursive1(TypedDict, total=False):
    """Arguments for user"""
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive2'


class category_to_articleArgsFromuserRecursive2(TypedDict, total=False):
    """Arguments for user"""
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive3'


class category_to_articleArgsFromuserRecursive3(TypedDict, total=False):
    """Arguments for user"""
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive4'


class category_to_articleArgsFromuserRecursive4(TypedDict, total=False):
    """Arguments for user"""
    
    

class FindManycategory_to_articleArgsFromuser(TypedDict, total=False):
    """Arguments for user"""
    take: int
    skip: int
    order_by: Union['category_to_articleOrderByInput', List['category_to_articleOrderByInput']]
    where: 'category_to_articleWhereInput'
    cursor: 'category_to_articleWhereUniqueInput'
    distinct: List['category_to_articleScalarFieldKeys']
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive1'


class FindManycategory_to_articleArgsFromuserRecursive1(TypedDict, total=False):
    """Arguments for user"""
    take: int
    skip: int
    order_by: Union['category_to_articleOrderByInput', List['category_to_articleOrderByInput']]
    where: 'category_to_articleWhereInput'
    cursor: 'category_to_articleWhereUniqueInput'
    distinct: List['category_to_articleScalarFieldKeys']
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive2'


class FindManycategory_to_articleArgsFromuserRecursive2(TypedDict, total=False):
    """Arguments for user"""
    take: int
    skip: int
    order_by: Union['category_to_articleOrderByInput', List['category_to_articleOrderByInput']]
    where: 'category_to_articleWhereInput'
    cursor: 'category_to_articleWhereUniqueInput'
    distinct: List['category_to_articleScalarFieldKeys']
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive3'


class FindManycategory_to_articleArgsFromuserRecursive3(TypedDict, total=False):
    """Arguments for user"""
    take: int
    skip: int
    order_by: Union['category_to_articleOrderByInput', List['category_to_articleOrderByInput']]
    where: 'category_to_articleWhereInput'
    cursor: 'category_to_articleWhereUniqueInput'
    distinct: List['category_to_articleScalarFieldKeys']
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive4'


class FindManycategory_to_articleArgsFromuserRecursive4(TypedDict, total=False):
    """Arguments for user"""
    take: int
    skip: int
    order_by: Union['category_to_articleOrderByInput', List['category_to_articleOrderByInput']]
    where: 'category_to_articleWhereInput'
    cursor: 'category_to_articleWhereUniqueInput'
    distinct: List['category_to_articleScalarFieldKeys']
    
    

class commentIncludeFromuser(TypedDict, total=False):
    """Relational arguments for user"""
    article: Union[bool, 'articleArgsFromuserRecursive1']
    user: Union[bool, 'userArgsFromuserRecursive1']


class commentIncludeFromuserRecursive1(TypedDict, total=False):
    """Relational arguments for user"""
    article: Union[bool, 'articleArgsFromuserRecursive2']
    user: Union[bool, 'userArgsFromuserRecursive2']


class commentIncludeFromuserRecursive2(TypedDict, total=False):
    """Relational arguments for user"""
    article: Union[bool, 'articleArgsFromuserRecursive3']
    user: Union[bool, 'userArgsFromuserRecursive3']


class commentIncludeFromuserRecursive3(TypedDict, total=False):
    """Relational arguments for user"""
    article: Union[bool, 'articleArgsFromuserRecursive4']
    user: Union[bool, 'userArgsFromuserRecursive4']


class commentIncludeFromuserRecursive4(TypedDict, total=False):
    """Relational arguments for user"""

    

class commentArgsFromuser(TypedDict, total=False):
    """Arguments for user"""
    include: 'commentIncludeFromcommentRecursive1'


class commentArgsFromuserRecursive1(TypedDict, total=False):
    """Arguments for user"""
    include: 'commentIncludeFromcommentRecursive2'


class commentArgsFromuserRecursive2(TypedDict, total=False):
    """Arguments for user"""
    include: 'commentIncludeFromcommentRecursive3'


class commentArgsFromuserRecursive3(TypedDict, total=False):
    """Arguments for user"""
    include: 'commentIncludeFromcommentRecursive4'


class commentArgsFromuserRecursive4(TypedDict, total=False):
    """Arguments for user"""
    
    

class FindManycommentArgsFromuser(TypedDict, total=False):
    """Arguments for user"""
    take: int
    skip: int
    order_by: Union['commentOrderByInput', List['commentOrderByInput']]
    where: 'commentWhereInput'
    cursor: 'commentWhereUniqueInput'
    distinct: List['commentScalarFieldKeys']
    include: 'commentIncludeFromcommentRecursive1'


class FindManycommentArgsFromuserRecursive1(TypedDict, total=False):
    """Arguments for user"""
    take: int
    skip: int
    order_by: Union['commentOrderByInput', List['commentOrderByInput']]
    where: 'commentWhereInput'
    cursor: 'commentWhereUniqueInput'
    distinct: List['commentScalarFieldKeys']
    include: 'commentIncludeFromcommentRecursive2'


class FindManycommentArgsFromuserRecursive2(TypedDict, total=False):
    """Arguments for user"""
    take: int
    skip: int
    order_by: Union['commentOrderByInput', List['commentOrderByInput']]
    where: 'commentWhereInput'
    cursor: 'commentWhereUniqueInput'
    distinct: List['commentScalarFieldKeys']
    include: 'commentIncludeFromcommentRecursive3'


class FindManycommentArgsFromuserRecursive3(TypedDict, total=False):
    """Arguments for user"""
    take: int
    skip: int
    order_by: Union['commentOrderByInput', List['commentOrderByInput']]
    where: 'commentWhereInput'
    cursor: 'commentWhereUniqueInput'
    distinct: List['commentScalarFieldKeys']
    include: 'commentIncludeFromcommentRecursive4'


class FindManycommentArgsFromuserRecursive4(TypedDict, total=False):
    """Arguments for user"""
    take: int
    skip: int
    order_by: Union['commentOrderByInput', List['commentOrderByInput']]
    where: 'commentWhereInput'
    cursor: 'commentWhereUniqueInput'
    distinct: List['commentScalarFieldKeys']
    
    

class likeIncludeFromuser(TypedDict, total=False):
    """Relational arguments for user"""
    article: Union[bool, 'articleArgsFromuserRecursive1']
    user: Union[bool, 'userArgsFromuserRecursive1']


class likeIncludeFromuserRecursive1(TypedDict, total=False):
    """Relational arguments for user"""
    article: Union[bool, 'articleArgsFromuserRecursive2']
    user: Union[bool, 'userArgsFromuserRecursive2']


class likeIncludeFromuserRecursive2(TypedDict, total=False):
    """Relational arguments for user"""
    article: Union[bool, 'articleArgsFromuserRecursive3']
    user: Union[bool, 'userArgsFromuserRecursive3']


class likeIncludeFromuserRecursive3(TypedDict, total=False):
    """Relational arguments for user"""
    article: Union[bool, 'articleArgsFromuserRecursive4']
    user: Union[bool, 'userArgsFromuserRecursive4']


class likeIncludeFromuserRecursive4(TypedDict, total=False):
    """Relational arguments for user"""

    

class likeArgsFromuser(TypedDict, total=False):
    """Arguments for user"""
    include: 'likeIncludeFromlikeRecursive1'


class likeArgsFromuserRecursive1(TypedDict, total=False):
    """Arguments for user"""
    include: 'likeIncludeFromlikeRecursive2'


class likeArgsFromuserRecursive2(TypedDict, total=False):
    """Arguments for user"""
    include: 'likeIncludeFromlikeRecursive3'


class likeArgsFromuserRecursive3(TypedDict, total=False):
    """Arguments for user"""
    include: 'likeIncludeFromlikeRecursive4'


class likeArgsFromuserRecursive4(TypedDict, total=False):
    """Arguments for user"""
    
    

class FindManylikeArgsFromuser(TypedDict, total=False):
    """Arguments for user"""
    take: int
    skip: int
    order_by: Union['likeOrderByInput', List['likeOrderByInput']]
    where: 'likeWhereInput'
    cursor: 'likeWhereUniqueInput'
    distinct: List['likeScalarFieldKeys']
    include: 'likeIncludeFromlikeRecursive1'


class FindManylikeArgsFromuserRecursive1(TypedDict, total=False):
    """Arguments for user"""
    take: int
    skip: int
    order_by: Union['likeOrderByInput', List['likeOrderByInput']]
    where: 'likeWhereInput'
    cursor: 'likeWhereUniqueInput'
    distinct: List['likeScalarFieldKeys']
    include: 'likeIncludeFromlikeRecursive2'


class FindManylikeArgsFromuserRecursive2(TypedDict, total=False):
    """Arguments for user"""
    take: int
    skip: int
    order_by: Union['likeOrderByInput', List['likeOrderByInput']]
    where: 'likeWhereInput'
    cursor: 'likeWhereUniqueInput'
    distinct: List['likeScalarFieldKeys']
    include: 'likeIncludeFromlikeRecursive3'


class FindManylikeArgsFromuserRecursive3(TypedDict, total=False):
    """Arguments for user"""
    take: int
    skip: int
    order_by: Union['likeOrderByInput', List['likeOrderByInput']]
    where: 'likeWhereInput'
    cursor: 'likeWhereUniqueInput'
    distinct: List['likeScalarFieldKeys']
    include: 'likeIncludeFromlikeRecursive4'


class FindManylikeArgsFromuserRecursive4(TypedDict, total=False):
    """Arguments for user"""
    take: int
    skip: int
    order_by: Union['likeOrderByInput', List['likeOrderByInput']]
    where: 'likeWhereInput'
    cursor: 'likeWhereUniqueInput'
    distinct: List['likeScalarFieldKeys']
    
    

class fileIncludeFromuser(TypedDict, total=False):
    """Relational arguments for user"""
    article: Union[bool, 'articleArgsFromuserRecursive1']


class fileIncludeFromuserRecursive1(TypedDict, total=False):
    """Relational arguments for user"""
    article: Union[bool, 'articleArgsFromuserRecursive2']


class fileIncludeFromuserRecursive2(TypedDict, total=False):
    """Relational arguments for user"""
    article: Union[bool, 'articleArgsFromuserRecursive3']


class fileIncludeFromuserRecursive3(TypedDict, total=False):
    """Relational arguments for user"""
    article: Union[bool, 'articleArgsFromuserRecursive4']


class fileIncludeFromuserRecursive4(TypedDict, total=False):
    """Relational arguments for user"""

    

class fileArgsFromuser(TypedDict, total=False):
    """Arguments for user"""
    include: 'fileIncludeFromfileRecursive1'


class fileArgsFromuserRecursive1(TypedDict, total=False):
    """Arguments for user"""
    include: 'fileIncludeFromfileRecursive2'


class fileArgsFromuserRecursive2(TypedDict, total=False):
    """Arguments for user"""
    include: 'fileIncludeFromfileRecursive3'


class fileArgsFromuserRecursive3(TypedDict, total=False):
    """Arguments for user"""
    include: 'fileIncludeFromfileRecursive4'


class fileArgsFromuserRecursive4(TypedDict, total=False):
    """Arguments for user"""
    
    

class FindManyfileArgsFromuser(TypedDict, total=False):
    """Arguments for user"""
    take: int
    skip: int
    order_by: Union['fileOrderByInput', List['fileOrderByInput']]
    where: 'fileWhereInput'
    cursor: 'fileWhereUniqueInput'
    distinct: List['fileScalarFieldKeys']
    include: 'fileIncludeFromfileRecursive1'


class FindManyfileArgsFromuserRecursive1(TypedDict, total=False):
    """Arguments for user"""
    take: int
    skip: int
    order_by: Union['fileOrderByInput', List['fileOrderByInput']]
    where: 'fileWhereInput'
    cursor: 'fileWhereUniqueInput'
    distinct: List['fileScalarFieldKeys']
    include: 'fileIncludeFromfileRecursive2'


class FindManyfileArgsFromuserRecursive2(TypedDict, total=False):
    """Arguments for user"""
    take: int
    skip: int
    order_by: Union['fileOrderByInput', List['fileOrderByInput']]
    where: 'fileWhereInput'
    cursor: 'fileWhereUniqueInput'
    distinct: List['fileScalarFieldKeys']
    include: 'fileIncludeFromfileRecursive3'


class FindManyfileArgsFromuserRecursive3(TypedDict, total=False):
    """Arguments for user"""
    take: int
    skip: int
    order_by: Union['fileOrderByInput', List['fileOrderByInput']]
    where: 'fileWhereInput'
    cursor: 'fileWhereUniqueInput'
    distinct: List['fileScalarFieldKeys']
    include: 'fileIncludeFromfileRecursive4'


class FindManyfileArgsFromuserRecursive4(TypedDict, total=False):
    """Arguments for user"""
    take: int
    skip: int
    order_by: Union['fileOrderByInput', List['fileOrderByInput']]
    where: 'fileWhereInput'
    cursor: 'fileWhereUniqueInput'
    distinct: List['fileScalarFieldKeys']
    


FindManyuserArgs = FindManyuserArgsFromuser
FindFirstuserArgs = FindManyuserArgsFromuser


    

class userWhereInput(TypedDict, total=False):
    """user arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    username: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    hashedpassword: Union[_str, 'types.StringFilter']
    role: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    articles: 'articleListRelationFilter'
    comments: 'commentListRelationFilter'
    likes: 'likeListRelationFilter'

    # should be noted that AND and NOT should be Union['userWhereInputRecursive1', List['userWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['userWhereInputRecursive1']
    OR: List['userWhereInputRecursive1']
    NOT: List['userWhereInputRecursive1']


class userWhereInputRecursive1(TypedDict, total=False):
    """user arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    username: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    hashedpassword: Union[_str, 'types.StringFilter']
    role: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    articles: 'articleListRelationFilter'
    comments: 'commentListRelationFilter'
    likes: 'likeListRelationFilter'

    # should be noted that AND and NOT should be Union['userWhereInputRecursive2', List['userWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['userWhereInputRecursive2']
    OR: List['userWhereInputRecursive2']
    NOT: List['userWhereInputRecursive2']


class userWhereInputRecursive2(TypedDict, total=False):
    """user arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    username: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    hashedpassword: Union[_str, 'types.StringFilter']
    role: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    articles: 'articleListRelationFilter'
    comments: 'commentListRelationFilter'
    likes: 'likeListRelationFilter'

    # should be noted that AND and NOT should be Union['userWhereInputRecursive3', List['userWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['userWhereInputRecursive3']
    OR: List['userWhereInputRecursive3']
    NOT: List['userWhereInputRecursive3']


class userWhereInputRecursive3(TypedDict, total=False):
    """user arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    username: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    hashedpassword: Union[_str, 'types.StringFilter']
    role: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    articles: 'articleListRelationFilter'
    comments: 'commentListRelationFilter'
    likes: 'likeListRelationFilter'

    # should be noted that AND and NOT should be Union['userWhereInputRecursive4', List['userWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['userWhereInputRecursive4']
    OR: List['userWhereInputRecursive4']
    NOT: List['userWhereInputRecursive4']


class userWhereInputRecursive4(TypedDict, total=False):
    """user arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    username: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    hashedpassword: Union[_str, 'types.StringFilter']
    role: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    articles: 'articleListRelationFilter'
    comments: 'commentListRelationFilter'
    likes: 'likeListRelationFilter'



# aggregate user types


    

class userScalarWhereWithAggregatesInput(TypedDict, total=False):
    """user arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    username: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    hashedpassword: Union[_str, 'types.StringWithAggregatesFilter']
    role: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['userScalarWhereWithAggregatesInputRecursive1']
    OR: List['userScalarWhereWithAggregatesInputRecursive1']
    NOT: List['userScalarWhereWithAggregatesInputRecursive1']


class userScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """user arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    username: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    hashedpassword: Union[_str, 'types.StringWithAggregatesFilter']
    role: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['userScalarWhereWithAggregatesInputRecursive2']
    OR: List['userScalarWhereWithAggregatesInputRecursive2']
    NOT: List['userScalarWhereWithAggregatesInputRecursive2']


class userScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """user arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    username: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    hashedpassword: Union[_str, 'types.StringWithAggregatesFilter']
    role: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['userScalarWhereWithAggregatesInputRecursive3']
    OR: List['userScalarWhereWithAggregatesInputRecursive3']
    NOT: List['userScalarWhereWithAggregatesInputRecursive3']


class userScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """user arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    username: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    hashedpassword: Union[_str, 'types.StringWithAggregatesFilter']
    role: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['userScalarWhereWithAggregatesInputRecursive4']
    OR: List['userScalarWhereWithAggregatesInputRecursive4']
    NOT: List['userScalarWhereWithAggregatesInputRecursive4']


class userScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """user arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    username: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    hashedpassword: Union[_str, 'types.StringWithAggregatesFilter']
    role: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class userGroupByOutput(TypedDict, total=False):
    id: _int
    username: _str
    email: _str
    hashedpassword: _str
    role: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    _sum: 'userSumAggregateOutput'
    _avg: 'userAvgAggregateOutput'
    _min: 'userMinAggregateOutput'
    _max: 'userMaxAggregateOutput'
    _count: 'userCountAggregateOutput'


class userAvgAggregateOutput(TypedDict, total=False):
    """user output for aggregating averages"""
    id: float


class userSumAggregateOutput(TypedDict, total=False):
    """user output for aggregating sums"""
    id: _int


class userScalarAggregateOutput(TypedDict, total=False):
    """user output including scalar fields"""
    id: _int
    username: _str
    email: _str
    hashedpassword: _str
    role: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime


userMinAggregateOutput = userScalarAggregateOutput
userMaxAggregateOutput = userScalarAggregateOutput


class userMaxAggregateInput(TypedDict, total=False):
    """user input for aggregating by max"""
    id: bool
    username: bool
    email: bool
    hashedpassword: bool
    role: bool
    created_at: bool
    updated_at: bool


class userMinAggregateInput(TypedDict, total=False):
    """user input for aggregating by min"""
    id: bool
    username: bool
    email: bool
    hashedpassword: bool
    role: bool
    created_at: bool
    updated_at: bool


class userNumberAggregateInput(TypedDict, total=False):
    """user input for aggregating numbers"""
    id: bool


userAvgAggregateInput = userNumberAggregateInput
userSumAggregateInput = userNumberAggregateInput


userCountAggregateInput = TypedDict(
    'userCountAggregateInput',
    {
        'id': bool,
        'username': bool,
        'email': bool,
        'hashedpassword': bool,
        'role': bool,
        'created_at': bool,
        'updated_at': bool,
        '_all': bool,
    },
    total=False,
)

userCountAggregateOutput = TypedDict(
    'userCountAggregateOutput',
    {
        'id': int,
        'username': int,
        'email': int,
        'hashedpassword': int,
        'role': int,
        'created_at': int,
        'updated_at': int,
        '_all': int,
    },
    total=False,
)


userKeys = Literal[
    'id',
    'username',
    'email',
    'hashedpassword',
    'role',
    'created_at',
    'updated_at',
    'articles',
    'comments',
    'likes',
]
userScalarFieldKeys = Literal[
    'id',
    'username',
    'email',
    'hashedpassword',
    'role',
    'created_at',
    'updated_at',
]
userScalarFieldKeysT = TypeVar('userScalarFieldKeysT', bound=userScalarFieldKeys)

userRelationalFieldKeys = Literal[
        'articles',
        'comments',
        'likes',
    ]

# article types

class articleOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the article create method"""
    id: _int
    views: _int
    created_at: datetime.datetime
    updated_at: datetime.datetime
    likes_count: _int
    user_id: _int
    user: 'userCreateNestedWithoutRelationsInput'
    comments: 'commentCreateManyNestedWithoutRelationsInput'
    likes: 'likeCreateManyNestedWithoutRelationsInput'
    categories: 'category_to_articleCreateManyNestedWithoutRelationsInput'
    files: 'fileCreateManyNestedWithoutRelationsInput'


class articleCreateInput(articleOptionalCreateInput):
    """Required arguments to the article create method"""
    title: _str
    content: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class articleOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the article create method, without relations"""
    id: _int
    views: _int
    created_at: datetime.datetime
    updated_at: datetime.datetime
    likes_count: _int
    user_id: _int


class articleCreateWithoutRelationsInput(articleOptionalCreateWithoutRelationsInput):
    """Required arguments to the article create method, without relations"""
    title: _str
    content: _str

class articleConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'articleCreateWithoutRelationsInput'
    where: 'articleWhereUniqueInput'

class articleCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'articleCreateWithoutRelationsInput'
    connect: 'articleWhereUniqueInput'
    connect_or_create: 'articleConnectOrCreateWithoutRelationsInput'


class articleCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['articleCreateWithoutRelationsInput', List['articleCreateWithoutRelationsInput']]
    connect: Union['articleWhereUniqueInput', List['articleWhereUniqueInput']]
    connect_or_create: Union['articleConnectOrCreateWithoutRelationsInput', List['articleConnectOrCreateWithoutRelationsInput']]

_articleWhereUnique_id_Input = TypedDict(
    '_articleWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

articleWhereUniqueInput = _articleWhereUnique_id_Input


class articleUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    title: _str
    content: _str
    views: Union[AtomicIntInput, _int]
    created_at: datetime.datetime
    updated_at: datetime.datetime
    likes_count: Union[AtomicIntInput, _int]
    user: 'userUpdateOneWithoutRelationsInput'
    comments: 'commentUpdateManyWithoutRelationsInput'
    likes: 'likeUpdateManyWithoutRelationsInput'
    categories: 'category_to_articleUpdateManyWithoutRelationsInput'
    files: 'fileUpdateManyWithoutRelationsInput'


class articleUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    title: _str
    content: _str
    views: Union[AtomicIntInput, _int]
    created_at: datetime.datetime
    updated_at: datetime.datetime
    likes_count: Union[AtomicIntInput, _int]


class articleUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['articleCreateWithoutRelationsInput']
    connect: List['articleWhereUniqueInput']
    connect_or_create: List['articleConnectOrCreateWithoutRelationsInput']
    set: List['articleWhereUniqueInput']
    disconnect: List['articleWhereUniqueInput']
    delete: List['articleWhereUniqueInput']

    # TODO
    # update: List['articleUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['articleUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['articleScalarWhereInput']
    # upsert: List['articleUpserteWithWhereUniqueWithoutRelationsInput']


class articleUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'articleCreateWithoutRelationsInput'
    connect: 'articleWhereUniqueInput'
    connect_or_create: 'articleConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'articleUpdateInput'
    # upsert: 'articleUpsertWithoutRelationsInput'


class articleUpsertInput(TypedDict):
    create: 'articleCreateInput'
    update: 'articleUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_article_id_OrderByInput = TypedDict(
    '_article_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_article_title_OrderByInput = TypedDict(
    '_article_title_OrderByInput',
    {
        'title': 'SortOrder',
    },
    total=True
)

_article_content_OrderByInput = TypedDict(
    '_article_content_OrderByInput',
    {
        'content': 'SortOrder',
    },
    total=True
)

_article_views_OrderByInput = TypedDict(
    '_article_views_OrderByInput',
    {
        'views': 'SortOrder',
    },
    total=True
)

_article_created_at_OrderByInput = TypedDict(
    '_article_created_at_OrderByInput',
    {
        'created_at': 'SortOrder',
    },
    total=True
)

_article_updated_at_OrderByInput = TypedDict(
    '_article_updated_at_OrderByInput',
    {
        'updated_at': 'SortOrder',
    },
    total=True
)

_article_likes_count_OrderByInput = TypedDict(
    '_article_likes_count_OrderByInput',
    {
        'likes_count': 'SortOrder',
    },
    total=True
)

_article_user_id_OrderByInput = TypedDict(
    '_article_user_id_OrderByInput',
    {
        'user_id': 'SortOrder',
    },
    total=True
)

_article_RelevanceInner = TypedDict(
    '_article_RelevanceInner',
    {
        'fields': 'List[articleScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_article_RelevanceOrderByInput = TypedDict(
    '_article_RelevanceOrderByInput',
    {
        '_relevance': '_article_RelevanceInner',
    },
    total=True
)

articleOrderByInput = Union[
    '_article_id_OrderByInput',
    '_article_title_OrderByInput',
    '_article_content_OrderByInput',
    '_article_views_OrderByInput',
    '_article_created_at_OrderByInput',
    '_article_updated_at_OrderByInput',
    '_article_likes_count_OrderByInput',
    '_article_user_id_OrderByInput',
    '_article_RelevanceOrderByInput',
]



# recursive article types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

articleRelationFilter = TypedDict(
    'articleRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class articleListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class articleInclude(TypedDict, total=False):
    """article relational arguments"""
    user: Union[bool, 'userArgsFromarticle']
    comments: Union[bool, 'FindManycommentArgsFromarticle']
    likes: Union[bool, 'FindManylikeArgsFromarticle']
    categories: Union[bool, 'FindManycategory_to_articleArgsFromarticle']
    files: Union[bool, 'FindManyfileArgsFromarticle']


    

class userIncludeFromarticle(TypedDict, total=False):
    """Relational arguments for article"""
    articles: Union[bool, 'FindManyarticleArgsFromarticleRecursive1']
    comments: Union[bool, 'FindManycommentArgsFromarticleRecursive1']
    likes: Union[bool, 'FindManylikeArgsFromarticleRecursive1']


class userIncludeFromarticleRecursive1(TypedDict, total=False):
    """Relational arguments for article"""
    articles: Union[bool, 'FindManyarticleArgsFromarticleRecursive2']
    comments: Union[bool, 'FindManycommentArgsFromarticleRecursive2']
    likes: Union[bool, 'FindManylikeArgsFromarticleRecursive2']


class userIncludeFromarticleRecursive2(TypedDict, total=False):
    """Relational arguments for article"""
    articles: Union[bool, 'FindManyarticleArgsFromarticleRecursive3']
    comments: Union[bool, 'FindManycommentArgsFromarticleRecursive3']
    likes: Union[bool, 'FindManylikeArgsFromarticleRecursive3']


class userIncludeFromarticleRecursive3(TypedDict, total=False):
    """Relational arguments for article"""
    articles: Union[bool, 'FindManyarticleArgsFromarticleRecursive4']
    comments: Union[bool, 'FindManycommentArgsFromarticleRecursive4']
    likes: Union[bool, 'FindManylikeArgsFromarticleRecursive4']


class userIncludeFromarticleRecursive4(TypedDict, total=False):
    """Relational arguments for article"""

    

class userArgsFromarticle(TypedDict, total=False):
    """Arguments for article"""
    include: 'userIncludeFromuserRecursive1'


class userArgsFromarticleRecursive1(TypedDict, total=False):
    """Arguments for article"""
    include: 'userIncludeFromuserRecursive2'


class userArgsFromarticleRecursive2(TypedDict, total=False):
    """Arguments for article"""
    include: 'userIncludeFromuserRecursive3'


class userArgsFromarticleRecursive3(TypedDict, total=False):
    """Arguments for article"""
    include: 'userIncludeFromuserRecursive4'


class userArgsFromarticleRecursive4(TypedDict, total=False):
    """Arguments for article"""
    
    

class FindManyuserArgsFromarticle(TypedDict, total=False):
    """Arguments for article"""
    take: int
    skip: int
    order_by: Union['userOrderByInput', List['userOrderByInput']]
    where: 'userWhereInput'
    cursor: 'userWhereUniqueInput'
    distinct: List['userScalarFieldKeys']
    include: 'userIncludeFromuserRecursive1'


class FindManyuserArgsFromarticleRecursive1(TypedDict, total=False):
    """Arguments for article"""
    take: int
    skip: int
    order_by: Union['userOrderByInput', List['userOrderByInput']]
    where: 'userWhereInput'
    cursor: 'userWhereUniqueInput'
    distinct: List['userScalarFieldKeys']
    include: 'userIncludeFromuserRecursive2'


class FindManyuserArgsFromarticleRecursive2(TypedDict, total=False):
    """Arguments for article"""
    take: int
    skip: int
    order_by: Union['userOrderByInput', List['userOrderByInput']]
    where: 'userWhereInput'
    cursor: 'userWhereUniqueInput'
    distinct: List['userScalarFieldKeys']
    include: 'userIncludeFromuserRecursive3'


class FindManyuserArgsFromarticleRecursive3(TypedDict, total=False):
    """Arguments for article"""
    take: int
    skip: int
    order_by: Union['userOrderByInput', List['userOrderByInput']]
    where: 'userWhereInput'
    cursor: 'userWhereUniqueInput'
    distinct: List['userScalarFieldKeys']
    include: 'userIncludeFromuserRecursive4'


class FindManyuserArgsFromarticleRecursive4(TypedDict, total=False):
    """Arguments for article"""
    take: int
    skip: int
    order_by: Union['userOrderByInput', List['userOrderByInput']]
    where: 'userWhereInput'
    cursor: 'userWhereUniqueInput'
    distinct: List['userScalarFieldKeys']
    
    

class articleIncludeFromarticle(TypedDict, total=False):
    """Relational arguments for article"""
    user: Union[bool, 'userArgsFromarticleRecursive1']
    comments: Union[bool, 'FindManycommentArgsFromarticleRecursive1']
    likes: Union[bool, 'FindManylikeArgsFromarticleRecursive1']
    categories: Union[bool, 'FindManycategory_to_articleArgsFromarticleRecursive1']
    files: Union[bool, 'FindManyfileArgsFromarticleRecursive1']


class articleIncludeFromarticleRecursive1(TypedDict, total=False):
    """Relational arguments for article"""
    user: Union[bool, 'userArgsFromarticleRecursive2']
    comments: Union[bool, 'FindManycommentArgsFromarticleRecursive2']
    likes: Union[bool, 'FindManylikeArgsFromarticleRecursive2']
    categories: Union[bool, 'FindManycategory_to_articleArgsFromarticleRecursive2']
    files: Union[bool, 'FindManyfileArgsFromarticleRecursive2']


class articleIncludeFromarticleRecursive2(TypedDict, total=False):
    """Relational arguments for article"""
    user: Union[bool, 'userArgsFromarticleRecursive3']
    comments: Union[bool, 'FindManycommentArgsFromarticleRecursive3']
    likes: Union[bool, 'FindManylikeArgsFromarticleRecursive3']
    categories: Union[bool, 'FindManycategory_to_articleArgsFromarticleRecursive3']
    files: Union[bool, 'FindManyfileArgsFromarticleRecursive3']


class articleIncludeFromarticleRecursive3(TypedDict, total=False):
    """Relational arguments for article"""
    user: Union[bool, 'userArgsFromarticleRecursive4']
    comments: Union[bool, 'FindManycommentArgsFromarticleRecursive4']
    likes: Union[bool, 'FindManylikeArgsFromarticleRecursive4']
    categories: Union[bool, 'FindManycategory_to_articleArgsFromarticleRecursive4']
    files: Union[bool, 'FindManyfileArgsFromarticleRecursive4']


class articleIncludeFromarticleRecursive4(TypedDict, total=False):
    """Relational arguments for article"""

    

class articleArgsFromarticle(TypedDict, total=False):
    """Arguments for article"""
    include: 'articleIncludeFromarticleRecursive1'


class articleArgsFromarticleRecursive1(TypedDict, total=False):
    """Arguments for article"""
    include: 'articleIncludeFromarticleRecursive2'


class articleArgsFromarticleRecursive2(TypedDict, total=False):
    """Arguments for article"""
    include: 'articleIncludeFromarticleRecursive3'


class articleArgsFromarticleRecursive3(TypedDict, total=False):
    """Arguments for article"""
    include: 'articleIncludeFromarticleRecursive4'


class articleArgsFromarticleRecursive4(TypedDict, total=False):
    """Arguments for article"""
    
    

class FindManyarticleArgsFromarticle(TypedDict, total=False):
    """Arguments for article"""
    take: int
    skip: int
    order_by: Union['articleOrderByInput', List['articleOrderByInput']]
    where: 'articleWhereInput'
    cursor: 'articleWhereUniqueInput'
    distinct: List['articleScalarFieldKeys']
    include: 'articleIncludeFromarticleRecursive1'


class FindManyarticleArgsFromarticleRecursive1(TypedDict, total=False):
    """Arguments for article"""
    take: int
    skip: int
    order_by: Union['articleOrderByInput', List['articleOrderByInput']]
    where: 'articleWhereInput'
    cursor: 'articleWhereUniqueInput'
    distinct: List['articleScalarFieldKeys']
    include: 'articleIncludeFromarticleRecursive2'


class FindManyarticleArgsFromarticleRecursive2(TypedDict, total=False):
    """Arguments for article"""
    take: int
    skip: int
    order_by: Union['articleOrderByInput', List['articleOrderByInput']]
    where: 'articleWhereInput'
    cursor: 'articleWhereUniqueInput'
    distinct: List['articleScalarFieldKeys']
    include: 'articleIncludeFromarticleRecursive3'


class FindManyarticleArgsFromarticleRecursive3(TypedDict, total=False):
    """Arguments for article"""
    take: int
    skip: int
    order_by: Union['articleOrderByInput', List['articleOrderByInput']]
    where: 'articleWhereInput'
    cursor: 'articleWhereUniqueInput'
    distinct: List['articleScalarFieldKeys']
    include: 'articleIncludeFromarticleRecursive4'


class FindManyarticleArgsFromarticleRecursive4(TypedDict, total=False):
    """Arguments for article"""
    take: int
    skip: int
    order_by: Union['articleOrderByInput', List['articleOrderByInput']]
    where: 'articleWhereInput'
    cursor: 'articleWhereUniqueInput'
    distinct: List['articleScalarFieldKeys']
    
    

class categoryIncludeFromarticle(TypedDict, total=False):
    """Relational arguments for article"""
    articles: Union[bool, 'FindManycategory_to_articleArgsFromarticleRecursive1']


class categoryIncludeFromarticleRecursive1(TypedDict, total=False):
    """Relational arguments for article"""
    articles: Union[bool, 'FindManycategory_to_articleArgsFromarticleRecursive2']


class categoryIncludeFromarticleRecursive2(TypedDict, total=False):
    """Relational arguments for article"""
    articles: Union[bool, 'FindManycategory_to_articleArgsFromarticleRecursive3']


class categoryIncludeFromarticleRecursive3(TypedDict, total=False):
    """Relational arguments for article"""
    articles: Union[bool, 'FindManycategory_to_articleArgsFromarticleRecursive4']


class categoryIncludeFromarticleRecursive4(TypedDict, total=False):
    """Relational arguments for article"""

    

class categoryArgsFromarticle(TypedDict, total=False):
    """Arguments for article"""
    include: 'categoryIncludeFromcategoryRecursive1'


class categoryArgsFromarticleRecursive1(TypedDict, total=False):
    """Arguments for article"""
    include: 'categoryIncludeFromcategoryRecursive2'


class categoryArgsFromarticleRecursive2(TypedDict, total=False):
    """Arguments for article"""
    include: 'categoryIncludeFromcategoryRecursive3'


class categoryArgsFromarticleRecursive3(TypedDict, total=False):
    """Arguments for article"""
    include: 'categoryIncludeFromcategoryRecursive4'


class categoryArgsFromarticleRecursive4(TypedDict, total=False):
    """Arguments for article"""
    
    

class FindManycategoryArgsFromarticle(TypedDict, total=False):
    """Arguments for article"""
    take: int
    skip: int
    order_by: Union['categoryOrderByInput', List['categoryOrderByInput']]
    where: 'categoryWhereInput'
    cursor: 'categoryWhereUniqueInput'
    distinct: List['categoryScalarFieldKeys']
    include: 'categoryIncludeFromcategoryRecursive1'


class FindManycategoryArgsFromarticleRecursive1(TypedDict, total=False):
    """Arguments for article"""
    take: int
    skip: int
    order_by: Union['categoryOrderByInput', List['categoryOrderByInput']]
    where: 'categoryWhereInput'
    cursor: 'categoryWhereUniqueInput'
    distinct: List['categoryScalarFieldKeys']
    include: 'categoryIncludeFromcategoryRecursive2'


class FindManycategoryArgsFromarticleRecursive2(TypedDict, total=False):
    """Arguments for article"""
    take: int
    skip: int
    order_by: Union['categoryOrderByInput', List['categoryOrderByInput']]
    where: 'categoryWhereInput'
    cursor: 'categoryWhereUniqueInput'
    distinct: List['categoryScalarFieldKeys']
    include: 'categoryIncludeFromcategoryRecursive3'


class FindManycategoryArgsFromarticleRecursive3(TypedDict, total=False):
    """Arguments for article"""
    take: int
    skip: int
    order_by: Union['categoryOrderByInput', List['categoryOrderByInput']]
    where: 'categoryWhereInput'
    cursor: 'categoryWhereUniqueInput'
    distinct: List['categoryScalarFieldKeys']
    include: 'categoryIncludeFromcategoryRecursive4'


class FindManycategoryArgsFromarticleRecursive4(TypedDict, total=False):
    """Arguments for article"""
    take: int
    skip: int
    order_by: Union['categoryOrderByInput', List['categoryOrderByInput']]
    where: 'categoryWhereInput'
    cursor: 'categoryWhereUniqueInput'
    distinct: List['categoryScalarFieldKeys']
    
    

class category_to_articleIncludeFromarticle(TypedDict, total=False):
    """Relational arguments for article"""
    article: Union[bool, 'articleArgsFromarticleRecursive1']
    category: Union[bool, 'categoryArgsFromarticleRecursive1']


class category_to_articleIncludeFromarticleRecursive1(TypedDict, total=False):
    """Relational arguments for article"""
    article: Union[bool, 'articleArgsFromarticleRecursive2']
    category: Union[bool, 'categoryArgsFromarticleRecursive2']


class category_to_articleIncludeFromarticleRecursive2(TypedDict, total=False):
    """Relational arguments for article"""
    article: Union[bool, 'articleArgsFromarticleRecursive3']
    category: Union[bool, 'categoryArgsFromarticleRecursive3']


class category_to_articleIncludeFromarticleRecursive3(TypedDict, total=False):
    """Relational arguments for article"""
    article: Union[bool, 'articleArgsFromarticleRecursive4']
    category: Union[bool, 'categoryArgsFromarticleRecursive4']


class category_to_articleIncludeFromarticleRecursive4(TypedDict, total=False):
    """Relational arguments for article"""

    

class category_to_articleArgsFromarticle(TypedDict, total=False):
    """Arguments for article"""
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive1'


class category_to_articleArgsFromarticleRecursive1(TypedDict, total=False):
    """Arguments for article"""
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive2'


class category_to_articleArgsFromarticleRecursive2(TypedDict, total=False):
    """Arguments for article"""
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive3'


class category_to_articleArgsFromarticleRecursive3(TypedDict, total=False):
    """Arguments for article"""
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive4'


class category_to_articleArgsFromarticleRecursive4(TypedDict, total=False):
    """Arguments for article"""
    
    

class FindManycategory_to_articleArgsFromarticle(TypedDict, total=False):
    """Arguments for article"""
    take: int
    skip: int
    order_by: Union['category_to_articleOrderByInput', List['category_to_articleOrderByInput']]
    where: 'category_to_articleWhereInput'
    cursor: 'category_to_articleWhereUniqueInput'
    distinct: List['category_to_articleScalarFieldKeys']
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive1'


class FindManycategory_to_articleArgsFromarticleRecursive1(TypedDict, total=False):
    """Arguments for article"""
    take: int
    skip: int
    order_by: Union['category_to_articleOrderByInput', List['category_to_articleOrderByInput']]
    where: 'category_to_articleWhereInput'
    cursor: 'category_to_articleWhereUniqueInput'
    distinct: List['category_to_articleScalarFieldKeys']
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive2'


class FindManycategory_to_articleArgsFromarticleRecursive2(TypedDict, total=False):
    """Arguments for article"""
    take: int
    skip: int
    order_by: Union['category_to_articleOrderByInput', List['category_to_articleOrderByInput']]
    where: 'category_to_articleWhereInput'
    cursor: 'category_to_articleWhereUniqueInput'
    distinct: List['category_to_articleScalarFieldKeys']
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive3'


class FindManycategory_to_articleArgsFromarticleRecursive3(TypedDict, total=False):
    """Arguments for article"""
    take: int
    skip: int
    order_by: Union['category_to_articleOrderByInput', List['category_to_articleOrderByInput']]
    where: 'category_to_articleWhereInput'
    cursor: 'category_to_articleWhereUniqueInput'
    distinct: List['category_to_articleScalarFieldKeys']
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive4'


class FindManycategory_to_articleArgsFromarticleRecursive4(TypedDict, total=False):
    """Arguments for article"""
    take: int
    skip: int
    order_by: Union['category_to_articleOrderByInput', List['category_to_articleOrderByInput']]
    where: 'category_to_articleWhereInput'
    cursor: 'category_to_articleWhereUniqueInput'
    distinct: List['category_to_articleScalarFieldKeys']
    
    

class commentIncludeFromarticle(TypedDict, total=False):
    """Relational arguments for article"""
    article: Union[bool, 'articleArgsFromarticleRecursive1']
    user: Union[bool, 'userArgsFromarticleRecursive1']


class commentIncludeFromarticleRecursive1(TypedDict, total=False):
    """Relational arguments for article"""
    article: Union[bool, 'articleArgsFromarticleRecursive2']
    user: Union[bool, 'userArgsFromarticleRecursive2']


class commentIncludeFromarticleRecursive2(TypedDict, total=False):
    """Relational arguments for article"""
    article: Union[bool, 'articleArgsFromarticleRecursive3']
    user: Union[bool, 'userArgsFromarticleRecursive3']


class commentIncludeFromarticleRecursive3(TypedDict, total=False):
    """Relational arguments for article"""
    article: Union[bool, 'articleArgsFromarticleRecursive4']
    user: Union[bool, 'userArgsFromarticleRecursive4']


class commentIncludeFromarticleRecursive4(TypedDict, total=False):
    """Relational arguments for article"""

    

class commentArgsFromarticle(TypedDict, total=False):
    """Arguments for article"""
    include: 'commentIncludeFromcommentRecursive1'


class commentArgsFromarticleRecursive1(TypedDict, total=False):
    """Arguments for article"""
    include: 'commentIncludeFromcommentRecursive2'


class commentArgsFromarticleRecursive2(TypedDict, total=False):
    """Arguments for article"""
    include: 'commentIncludeFromcommentRecursive3'


class commentArgsFromarticleRecursive3(TypedDict, total=False):
    """Arguments for article"""
    include: 'commentIncludeFromcommentRecursive4'


class commentArgsFromarticleRecursive4(TypedDict, total=False):
    """Arguments for article"""
    
    

class FindManycommentArgsFromarticle(TypedDict, total=False):
    """Arguments for article"""
    take: int
    skip: int
    order_by: Union['commentOrderByInput', List['commentOrderByInput']]
    where: 'commentWhereInput'
    cursor: 'commentWhereUniqueInput'
    distinct: List['commentScalarFieldKeys']
    include: 'commentIncludeFromcommentRecursive1'


class FindManycommentArgsFromarticleRecursive1(TypedDict, total=False):
    """Arguments for article"""
    take: int
    skip: int
    order_by: Union['commentOrderByInput', List['commentOrderByInput']]
    where: 'commentWhereInput'
    cursor: 'commentWhereUniqueInput'
    distinct: List['commentScalarFieldKeys']
    include: 'commentIncludeFromcommentRecursive2'


class FindManycommentArgsFromarticleRecursive2(TypedDict, total=False):
    """Arguments for article"""
    take: int
    skip: int
    order_by: Union['commentOrderByInput', List['commentOrderByInput']]
    where: 'commentWhereInput'
    cursor: 'commentWhereUniqueInput'
    distinct: List['commentScalarFieldKeys']
    include: 'commentIncludeFromcommentRecursive3'


class FindManycommentArgsFromarticleRecursive3(TypedDict, total=False):
    """Arguments for article"""
    take: int
    skip: int
    order_by: Union['commentOrderByInput', List['commentOrderByInput']]
    where: 'commentWhereInput'
    cursor: 'commentWhereUniqueInput'
    distinct: List['commentScalarFieldKeys']
    include: 'commentIncludeFromcommentRecursive4'


class FindManycommentArgsFromarticleRecursive4(TypedDict, total=False):
    """Arguments for article"""
    take: int
    skip: int
    order_by: Union['commentOrderByInput', List['commentOrderByInput']]
    where: 'commentWhereInput'
    cursor: 'commentWhereUniqueInput'
    distinct: List['commentScalarFieldKeys']
    
    

class likeIncludeFromarticle(TypedDict, total=False):
    """Relational arguments for article"""
    article: Union[bool, 'articleArgsFromarticleRecursive1']
    user: Union[bool, 'userArgsFromarticleRecursive1']


class likeIncludeFromarticleRecursive1(TypedDict, total=False):
    """Relational arguments for article"""
    article: Union[bool, 'articleArgsFromarticleRecursive2']
    user: Union[bool, 'userArgsFromarticleRecursive2']


class likeIncludeFromarticleRecursive2(TypedDict, total=False):
    """Relational arguments for article"""
    article: Union[bool, 'articleArgsFromarticleRecursive3']
    user: Union[bool, 'userArgsFromarticleRecursive3']


class likeIncludeFromarticleRecursive3(TypedDict, total=False):
    """Relational arguments for article"""
    article: Union[bool, 'articleArgsFromarticleRecursive4']
    user: Union[bool, 'userArgsFromarticleRecursive4']


class likeIncludeFromarticleRecursive4(TypedDict, total=False):
    """Relational arguments for article"""

    

class likeArgsFromarticle(TypedDict, total=False):
    """Arguments for article"""
    include: 'likeIncludeFromlikeRecursive1'


class likeArgsFromarticleRecursive1(TypedDict, total=False):
    """Arguments for article"""
    include: 'likeIncludeFromlikeRecursive2'


class likeArgsFromarticleRecursive2(TypedDict, total=False):
    """Arguments for article"""
    include: 'likeIncludeFromlikeRecursive3'


class likeArgsFromarticleRecursive3(TypedDict, total=False):
    """Arguments for article"""
    include: 'likeIncludeFromlikeRecursive4'


class likeArgsFromarticleRecursive4(TypedDict, total=False):
    """Arguments for article"""
    
    

class FindManylikeArgsFromarticle(TypedDict, total=False):
    """Arguments for article"""
    take: int
    skip: int
    order_by: Union['likeOrderByInput', List['likeOrderByInput']]
    where: 'likeWhereInput'
    cursor: 'likeWhereUniqueInput'
    distinct: List['likeScalarFieldKeys']
    include: 'likeIncludeFromlikeRecursive1'


class FindManylikeArgsFromarticleRecursive1(TypedDict, total=False):
    """Arguments for article"""
    take: int
    skip: int
    order_by: Union['likeOrderByInput', List['likeOrderByInput']]
    where: 'likeWhereInput'
    cursor: 'likeWhereUniqueInput'
    distinct: List['likeScalarFieldKeys']
    include: 'likeIncludeFromlikeRecursive2'


class FindManylikeArgsFromarticleRecursive2(TypedDict, total=False):
    """Arguments for article"""
    take: int
    skip: int
    order_by: Union['likeOrderByInput', List['likeOrderByInput']]
    where: 'likeWhereInput'
    cursor: 'likeWhereUniqueInput'
    distinct: List['likeScalarFieldKeys']
    include: 'likeIncludeFromlikeRecursive3'


class FindManylikeArgsFromarticleRecursive3(TypedDict, total=False):
    """Arguments for article"""
    take: int
    skip: int
    order_by: Union['likeOrderByInput', List['likeOrderByInput']]
    where: 'likeWhereInput'
    cursor: 'likeWhereUniqueInput'
    distinct: List['likeScalarFieldKeys']
    include: 'likeIncludeFromlikeRecursive4'


class FindManylikeArgsFromarticleRecursive4(TypedDict, total=False):
    """Arguments for article"""
    take: int
    skip: int
    order_by: Union['likeOrderByInput', List['likeOrderByInput']]
    where: 'likeWhereInput'
    cursor: 'likeWhereUniqueInput'
    distinct: List['likeScalarFieldKeys']
    
    

class fileIncludeFromarticle(TypedDict, total=False):
    """Relational arguments for article"""
    article: Union[bool, 'articleArgsFromarticleRecursive1']


class fileIncludeFromarticleRecursive1(TypedDict, total=False):
    """Relational arguments for article"""
    article: Union[bool, 'articleArgsFromarticleRecursive2']


class fileIncludeFromarticleRecursive2(TypedDict, total=False):
    """Relational arguments for article"""
    article: Union[bool, 'articleArgsFromarticleRecursive3']


class fileIncludeFromarticleRecursive3(TypedDict, total=False):
    """Relational arguments for article"""
    article: Union[bool, 'articleArgsFromarticleRecursive4']


class fileIncludeFromarticleRecursive4(TypedDict, total=False):
    """Relational arguments for article"""

    

class fileArgsFromarticle(TypedDict, total=False):
    """Arguments for article"""
    include: 'fileIncludeFromfileRecursive1'


class fileArgsFromarticleRecursive1(TypedDict, total=False):
    """Arguments for article"""
    include: 'fileIncludeFromfileRecursive2'


class fileArgsFromarticleRecursive2(TypedDict, total=False):
    """Arguments for article"""
    include: 'fileIncludeFromfileRecursive3'


class fileArgsFromarticleRecursive3(TypedDict, total=False):
    """Arguments for article"""
    include: 'fileIncludeFromfileRecursive4'


class fileArgsFromarticleRecursive4(TypedDict, total=False):
    """Arguments for article"""
    
    

class FindManyfileArgsFromarticle(TypedDict, total=False):
    """Arguments for article"""
    take: int
    skip: int
    order_by: Union['fileOrderByInput', List['fileOrderByInput']]
    where: 'fileWhereInput'
    cursor: 'fileWhereUniqueInput'
    distinct: List['fileScalarFieldKeys']
    include: 'fileIncludeFromfileRecursive1'


class FindManyfileArgsFromarticleRecursive1(TypedDict, total=False):
    """Arguments for article"""
    take: int
    skip: int
    order_by: Union['fileOrderByInput', List['fileOrderByInput']]
    where: 'fileWhereInput'
    cursor: 'fileWhereUniqueInput'
    distinct: List['fileScalarFieldKeys']
    include: 'fileIncludeFromfileRecursive2'


class FindManyfileArgsFromarticleRecursive2(TypedDict, total=False):
    """Arguments for article"""
    take: int
    skip: int
    order_by: Union['fileOrderByInput', List['fileOrderByInput']]
    where: 'fileWhereInput'
    cursor: 'fileWhereUniqueInput'
    distinct: List['fileScalarFieldKeys']
    include: 'fileIncludeFromfileRecursive3'


class FindManyfileArgsFromarticleRecursive3(TypedDict, total=False):
    """Arguments for article"""
    take: int
    skip: int
    order_by: Union['fileOrderByInput', List['fileOrderByInput']]
    where: 'fileWhereInput'
    cursor: 'fileWhereUniqueInput'
    distinct: List['fileScalarFieldKeys']
    include: 'fileIncludeFromfileRecursive4'


class FindManyfileArgsFromarticleRecursive4(TypedDict, total=False):
    """Arguments for article"""
    take: int
    skip: int
    order_by: Union['fileOrderByInput', List['fileOrderByInput']]
    where: 'fileWhereInput'
    cursor: 'fileWhereUniqueInput'
    distinct: List['fileScalarFieldKeys']
    


FindManyarticleArgs = FindManyarticleArgsFromarticle
FindFirstarticleArgs = FindManyarticleArgsFromarticle


    

class articleWhereInput(TypedDict, total=False):
    """article arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    title: Union[_str, 'types.StringFilter']
    content: Union[_str, 'types.StringFilter']
    views: Union[_int, 'types.IntFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    likes_count: Union[_int, 'types.IntFilter']
    user_id: Union[_int, 'types.IntFilter']
    user: 'userRelationFilter'
    comments: 'commentListRelationFilter'
    likes: 'likeListRelationFilter'
    categories: 'category_to_articleListRelationFilter'
    files: 'fileListRelationFilter'

    # should be noted that AND and NOT should be Union['articleWhereInputRecursive1', List['articleWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['articleWhereInputRecursive1']
    OR: List['articleWhereInputRecursive1']
    NOT: List['articleWhereInputRecursive1']


class articleWhereInputRecursive1(TypedDict, total=False):
    """article arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    title: Union[_str, 'types.StringFilter']
    content: Union[_str, 'types.StringFilter']
    views: Union[_int, 'types.IntFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    likes_count: Union[_int, 'types.IntFilter']
    user_id: Union[_int, 'types.IntFilter']
    user: 'userRelationFilter'
    comments: 'commentListRelationFilter'
    likes: 'likeListRelationFilter'
    categories: 'category_to_articleListRelationFilter'
    files: 'fileListRelationFilter'

    # should be noted that AND and NOT should be Union['articleWhereInputRecursive2', List['articleWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['articleWhereInputRecursive2']
    OR: List['articleWhereInputRecursive2']
    NOT: List['articleWhereInputRecursive2']


class articleWhereInputRecursive2(TypedDict, total=False):
    """article arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    title: Union[_str, 'types.StringFilter']
    content: Union[_str, 'types.StringFilter']
    views: Union[_int, 'types.IntFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    likes_count: Union[_int, 'types.IntFilter']
    user_id: Union[_int, 'types.IntFilter']
    user: 'userRelationFilter'
    comments: 'commentListRelationFilter'
    likes: 'likeListRelationFilter'
    categories: 'category_to_articleListRelationFilter'
    files: 'fileListRelationFilter'

    # should be noted that AND and NOT should be Union['articleWhereInputRecursive3', List['articleWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['articleWhereInputRecursive3']
    OR: List['articleWhereInputRecursive3']
    NOT: List['articleWhereInputRecursive3']


class articleWhereInputRecursive3(TypedDict, total=False):
    """article arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    title: Union[_str, 'types.StringFilter']
    content: Union[_str, 'types.StringFilter']
    views: Union[_int, 'types.IntFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    likes_count: Union[_int, 'types.IntFilter']
    user_id: Union[_int, 'types.IntFilter']
    user: 'userRelationFilter'
    comments: 'commentListRelationFilter'
    likes: 'likeListRelationFilter'
    categories: 'category_to_articleListRelationFilter'
    files: 'fileListRelationFilter'

    # should be noted that AND and NOT should be Union['articleWhereInputRecursive4', List['articleWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['articleWhereInputRecursive4']
    OR: List['articleWhereInputRecursive4']
    NOT: List['articleWhereInputRecursive4']


class articleWhereInputRecursive4(TypedDict, total=False):
    """article arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    title: Union[_str, 'types.StringFilter']
    content: Union[_str, 'types.StringFilter']
    views: Union[_int, 'types.IntFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    likes_count: Union[_int, 'types.IntFilter']
    user_id: Union[_int, 'types.IntFilter']
    user: 'userRelationFilter'
    comments: 'commentListRelationFilter'
    likes: 'likeListRelationFilter'
    categories: 'category_to_articleListRelationFilter'
    files: 'fileListRelationFilter'



# aggregate article types


    

class articleScalarWhereWithAggregatesInput(TypedDict, total=False):
    """article arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    title: Union[_str, 'types.StringWithAggregatesFilter']
    content: Union[_str, 'types.StringWithAggregatesFilter']
    views: Union[_int, 'types.IntWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    likes_count: Union[_int, 'types.IntWithAggregatesFilter']
    user_id: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['articleScalarWhereWithAggregatesInputRecursive1']
    OR: List['articleScalarWhereWithAggregatesInputRecursive1']
    NOT: List['articleScalarWhereWithAggregatesInputRecursive1']


class articleScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """article arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    title: Union[_str, 'types.StringWithAggregatesFilter']
    content: Union[_str, 'types.StringWithAggregatesFilter']
    views: Union[_int, 'types.IntWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    likes_count: Union[_int, 'types.IntWithAggregatesFilter']
    user_id: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['articleScalarWhereWithAggregatesInputRecursive2']
    OR: List['articleScalarWhereWithAggregatesInputRecursive2']
    NOT: List['articleScalarWhereWithAggregatesInputRecursive2']


class articleScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """article arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    title: Union[_str, 'types.StringWithAggregatesFilter']
    content: Union[_str, 'types.StringWithAggregatesFilter']
    views: Union[_int, 'types.IntWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    likes_count: Union[_int, 'types.IntWithAggregatesFilter']
    user_id: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['articleScalarWhereWithAggregatesInputRecursive3']
    OR: List['articleScalarWhereWithAggregatesInputRecursive3']
    NOT: List['articleScalarWhereWithAggregatesInputRecursive3']


class articleScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """article arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    title: Union[_str, 'types.StringWithAggregatesFilter']
    content: Union[_str, 'types.StringWithAggregatesFilter']
    views: Union[_int, 'types.IntWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    likes_count: Union[_int, 'types.IntWithAggregatesFilter']
    user_id: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['articleScalarWhereWithAggregatesInputRecursive4']
    OR: List['articleScalarWhereWithAggregatesInputRecursive4']
    NOT: List['articleScalarWhereWithAggregatesInputRecursive4']


class articleScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """article arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    title: Union[_str, 'types.StringWithAggregatesFilter']
    content: Union[_str, 'types.StringWithAggregatesFilter']
    views: Union[_int, 'types.IntWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    likes_count: Union[_int, 'types.IntWithAggregatesFilter']
    user_id: Union[_int, 'types.IntWithAggregatesFilter']



class articleGroupByOutput(TypedDict, total=False):
    id: _int
    title: _str
    content: _str
    views: _int
    created_at: datetime.datetime
    updated_at: datetime.datetime
    likes_count: _int
    user_id: _int
    _sum: 'articleSumAggregateOutput'
    _avg: 'articleAvgAggregateOutput'
    _min: 'articleMinAggregateOutput'
    _max: 'articleMaxAggregateOutput'
    _count: 'articleCountAggregateOutput'


class articleAvgAggregateOutput(TypedDict, total=False):
    """article output for aggregating averages"""
    id: float
    views: float
    likes_count: float
    user_id: float


class articleSumAggregateOutput(TypedDict, total=False):
    """article output for aggregating sums"""
    id: _int
    views: _int
    likes_count: _int
    user_id: _int


class articleScalarAggregateOutput(TypedDict, total=False):
    """article output including scalar fields"""
    id: _int
    title: _str
    content: _str
    views: _int
    created_at: datetime.datetime
    updated_at: datetime.datetime
    likes_count: _int
    user_id: _int


articleMinAggregateOutput = articleScalarAggregateOutput
articleMaxAggregateOutput = articleScalarAggregateOutput


class articleMaxAggregateInput(TypedDict, total=False):
    """article input for aggregating by max"""
    id: bool
    title: bool
    content: bool
    views: bool
    created_at: bool
    updated_at: bool
    likes_count: bool
    user_id: bool


class articleMinAggregateInput(TypedDict, total=False):
    """article input for aggregating by min"""
    id: bool
    title: bool
    content: bool
    views: bool
    created_at: bool
    updated_at: bool
    likes_count: bool
    user_id: bool


class articleNumberAggregateInput(TypedDict, total=False):
    """article input for aggregating numbers"""
    id: bool
    views: bool
    likes_count: bool
    user_id: bool


articleAvgAggregateInput = articleNumberAggregateInput
articleSumAggregateInput = articleNumberAggregateInput


articleCountAggregateInput = TypedDict(
    'articleCountAggregateInput',
    {
        'id': bool,
        'title': bool,
        'content': bool,
        'views': bool,
        'created_at': bool,
        'updated_at': bool,
        'likes_count': bool,
        'user_id': bool,
        '_all': bool,
    },
    total=False,
)

articleCountAggregateOutput = TypedDict(
    'articleCountAggregateOutput',
    {
        'id': int,
        'title': int,
        'content': int,
        'views': int,
        'created_at': int,
        'updated_at': int,
        'likes_count': int,
        'user_id': int,
        '_all': int,
    },
    total=False,
)


articleKeys = Literal[
    'id',
    'title',
    'content',
    'views',
    'created_at',
    'updated_at',
    'likes_count',
    'user_id',
    'user',
    'comments',
    'likes',
    'categories',
    'files',
]
articleScalarFieldKeys = Literal[
    'id',
    'title',
    'content',
    'views',
    'created_at',
    'updated_at',
    'likes_count',
    'user_id',
]
articleScalarFieldKeysT = TypeVar('articleScalarFieldKeysT', bound=articleScalarFieldKeys)

articleRelationalFieldKeys = Literal[
        'user',
        'comments',
        'likes',
        'categories',
        'files',
    ]

# category types

class categoryOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the category create method"""
    id: _int
    articles: 'category_to_articleCreateManyNestedWithoutRelationsInput'


class categoryCreateInput(categoryOptionalCreateInput):
    """Required arguments to the category create method"""
    name: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class categoryOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the category create method, without relations"""
    id: _int


class categoryCreateWithoutRelationsInput(categoryOptionalCreateWithoutRelationsInput):
    """Required arguments to the category create method, without relations"""
    name: _str

class categoryConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'categoryCreateWithoutRelationsInput'
    where: 'categoryWhereUniqueInput'

class categoryCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'categoryCreateWithoutRelationsInput'
    connect: 'categoryWhereUniqueInput'
    connect_or_create: 'categoryConnectOrCreateWithoutRelationsInput'


class categoryCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['categoryCreateWithoutRelationsInput', List['categoryCreateWithoutRelationsInput']]
    connect: Union['categoryWhereUniqueInput', List['categoryWhereUniqueInput']]
    connect_or_create: Union['categoryConnectOrCreateWithoutRelationsInput', List['categoryConnectOrCreateWithoutRelationsInput']]

_categoryWhereUnique_id_Input = TypedDict(
    '_categoryWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

categoryWhereUniqueInput = _categoryWhereUnique_id_Input


class categoryUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    name: _str
    articles: 'category_to_articleUpdateManyWithoutRelationsInput'


class categoryUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    name: _str


class categoryUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['categoryCreateWithoutRelationsInput']
    connect: List['categoryWhereUniqueInput']
    connect_or_create: List['categoryConnectOrCreateWithoutRelationsInput']
    set: List['categoryWhereUniqueInput']
    disconnect: List['categoryWhereUniqueInput']
    delete: List['categoryWhereUniqueInput']

    # TODO
    # update: List['categoryUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['categoryUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['categoryScalarWhereInput']
    # upsert: List['categoryUpserteWithWhereUniqueWithoutRelationsInput']


class categoryUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'categoryCreateWithoutRelationsInput'
    connect: 'categoryWhereUniqueInput'
    connect_or_create: 'categoryConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'categoryUpdateInput'
    # upsert: 'categoryUpsertWithoutRelationsInput'


class categoryUpsertInput(TypedDict):
    create: 'categoryCreateInput'
    update: 'categoryUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_category_id_OrderByInput = TypedDict(
    '_category_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_category_name_OrderByInput = TypedDict(
    '_category_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_category_RelevanceInner = TypedDict(
    '_category_RelevanceInner',
    {
        'fields': 'List[categoryScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_category_RelevanceOrderByInput = TypedDict(
    '_category_RelevanceOrderByInput',
    {
        '_relevance': '_category_RelevanceInner',
    },
    total=True
)

categoryOrderByInput = Union[
    '_category_id_OrderByInput',
    '_category_name_OrderByInput',
    '_category_RelevanceOrderByInput',
]



# recursive category types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

categoryRelationFilter = TypedDict(
    'categoryRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class categoryListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class categoryInclude(TypedDict, total=False):
    """category relational arguments"""
    articles: Union[bool, 'FindManycategory_to_articleArgsFromcategory']


    

class userIncludeFromcategory(TypedDict, total=False):
    """Relational arguments for category"""
    articles: Union[bool, 'FindManyarticleArgsFromcategoryRecursive1']
    comments: Union[bool, 'FindManycommentArgsFromcategoryRecursive1']
    likes: Union[bool, 'FindManylikeArgsFromcategoryRecursive1']


class userIncludeFromcategoryRecursive1(TypedDict, total=False):
    """Relational arguments for category"""
    articles: Union[bool, 'FindManyarticleArgsFromcategoryRecursive2']
    comments: Union[bool, 'FindManycommentArgsFromcategoryRecursive2']
    likes: Union[bool, 'FindManylikeArgsFromcategoryRecursive2']


class userIncludeFromcategoryRecursive2(TypedDict, total=False):
    """Relational arguments for category"""
    articles: Union[bool, 'FindManyarticleArgsFromcategoryRecursive3']
    comments: Union[bool, 'FindManycommentArgsFromcategoryRecursive3']
    likes: Union[bool, 'FindManylikeArgsFromcategoryRecursive3']


class userIncludeFromcategoryRecursive3(TypedDict, total=False):
    """Relational arguments for category"""
    articles: Union[bool, 'FindManyarticleArgsFromcategoryRecursive4']
    comments: Union[bool, 'FindManycommentArgsFromcategoryRecursive4']
    likes: Union[bool, 'FindManylikeArgsFromcategoryRecursive4']


class userIncludeFromcategoryRecursive4(TypedDict, total=False):
    """Relational arguments for category"""

    

class userArgsFromcategory(TypedDict, total=False):
    """Arguments for category"""
    include: 'userIncludeFromuserRecursive1'


class userArgsFromcategoryRecursive1(TypedDict, total=False):
    """Arguments for category"""
    include: 'userIncludeFromuserRecursive2'


class userArgsFromcategoryRecursive2(TypedDict, total=False):
    """Arguments for category"""
    include: 'userIncludeFromuserRecursive3'


class userArgsFromcategoryRecursive3(TypedDict, total=False):
    """Arguments for category"""
    include: 'userIncludeFromuserRecursive4'


class userArgsFromcategoryRecursive4(TypedDict, total=False):
    """Arguments for category"""
    
    

class FindManyuserArgsFromcategory(TypedDict, total=False):
    """Arguments for category"""
    take: int
    skip: int
    order_by: Union['userOrderByInput', List['userOrderByInput']]
    where: 'userWhereInput'
    cursor: 'userWhereUniqueInput'
    distinct: List['userScalarFieldKeys']
    include: 'userIncludeFromuserRecursive1'


class FindManyuserArgsFromcategoryRecursive1(TypedDict, total=False):
    """Arguments for category"""
    take: int
    skip: int
    order_by: Union['userOrderByInput', List['userOrderByInput']]
    where: 'userWhereInput'
    cursor: 'userWhereUniqueInput'
    distinct: List['userScalarFieldKeys']
    include: 'userIncludeFromuserRecursive2'


class FindManyuserArgsFromcategoryRecursive2(TypedDict, total=False):
    """Arguments for category"""
    take: int
    skip: int
    order_by: Union['userOrderByInput', List['userOrderByInput']]
    where: 'userWhereInput'
    cursor: 'userWhereUniqueInput'
    distinct: List['userScalarFieldKeys']
    include: 'userIncludeFromuserRecursive3'


class FindManyuserArgsFromcategoryRecursive3(TypedDict, total=False):
    """Arguments for category"""
    take: int
    skip: int
    order_by: Union['userOrderByInput', List['userOrderByInput']]
    where: 'userWhereInput'
    cursor: 'userWhereUniqueInput'
    distinct: List['userScalarFieldKeys']
    include: 'userIncludeFromuserRecursive4'


class FindManyuserArgsFromcategoryRecursive4(TypedDict, total=False):
    """Arguments for category"""
    take: int
    skip: int
    order_by: Union['userOrderByInput', List['userOrderByInput']]
    where: 'userWhereInput'
    cursor: 'userWhereUniqueInput'
    distinct: List['userScalarFieldKeys']
    
    

class articleIncludeFromcategory(TypedDict, total=False):
    """Relational arguments for category"""
    user: Union[bool, 'userArgsFromcategoryRecursive1']
    comments: Union[bool, 'FindManycommentArgsFromcategoryRecursive1']
    likes: Union[bool, 'FindManylikeArgsFromcategoryRecursive1']
    categories: Union[bool, 'FindManycategory_to_articleArgsFromcategoryRecursive1']
    files: Union[bool, 'FindManyfileArgsFromcategoryRecursive1']


class articleIncludeFromcategoryRecursive1(TypedDict, total=False):
    """Relational arguments for category"""
    user: Union[bool, 'userArgsFromcategoryRecursive2']
    comments: Union[bool, 'FindManycommentArgsFromcategoryRecursive2']
    likes: Union[bool, 'FindManylikeArgsFromcategoryRecursive2']
    categories: Union[bool, 'FindManycategory_to_articleArgsFromcategoryRecursive2']
    files: Union[bool, 'FindManyfileArgsFromcategoryRecursive2']


class articleIncludeFromcategoryRecursive2(TypedDict, total=False):
    """Relational arguments for category"""
    user: Union[bool, 'userArgsFromcategoryRecursive3']
    comments: Union[bool, 'FindManycommentArgsFromcategoryRecursive3']
    likes: Union[bool, 'FindManylikeArgsFromcategoryRecursive3']
    categories: Union[bool, 'FindManycategory_to_articleArgsFromcategoryRecursive3']
    files: Union[bool, 'FindManyfileArgsFromcategoryRecursive3']


class articleIncludeFromcategoryRecursive3(TypedDict, total=False):
    """Relational arguments for category"""
    user: Union[bool, 'userArgsFromcategoryRecursive4']
    comments: Union[bool, 'FindManycommentArgsFromcategoryRecursive4']
    likes: Union[bool, 'FindManylikeArgsFromcategoryRecursive4']
    categories: Union[bool, 'FindManycategory_to_articleArgsFromcategoryRecursive4']
    files: Union[bool, 'FindManyfileArgsFromcategoryRecursive4']


class articleIncludeFromcategoryRecursive4(TypedDict, total=False):
    """Relational arguments for category"""

    

class articleArgsFromcategory(TypedDict, total=False):
    """Arguments for category"""
    include: 'articleIncludeFromarticleRecursive1'


class articleArgsFromcategoryRecursive1(TypedDict, total=False):
    """Arguments for category"""
    include: 'articleIncludeFromarticleRecursive2'


class articleArgsFromcategoryRecursive2(TypedDict, total=False):
    """Arguments for category"""
    include: 'articleIncludeFromarticleRecursive3'


class articleArgsFromcategoryRecursive3(TypedDict, total=False):
    """Arguments for category"""
    include: 'articleIncludeFromarticleRecursive4'


class articleArgsFromcategoryRecursive4(TypedDict, total=False):
    """Arguments for category"""
    
    

class FindManyarticleArgsFromcategory(TypedDict, total=False):
    """Arguments for category"""
    take: int
    skip: int
    order_by: Union['articleOrderByInput', List['articleOrderByInput']]
    where: 'articleWhereInput'
    cursor: 'articleWhereUniqueInput'
    distinct: List['articleScalarFieldKeys']
    include: 'articleIncludeFromarticleRecursive1'


class FindManyarticleArgsFromcategoryRecursive1(TypedDict, total=False):
    """Arguments for category"""
    take: int
    skip: int
    order_by: Union['articleOrderByInput', List['articleOrderByInput']]
    where: 'articleWhereInput'
    cursor: 'articleWhereUniqueInput'
    distinct: List['articleScalarFieldKeys']
    include: 'articleIncludeFromarticleRecursive2'


class FindManyarticleArgsFromcategoryRecursive2(TypedDict, total=False):
    """Arguments for category"""
    take: int
    skip: int
    order_by: Union['articleOrderByInput', List['articleOrderByInput']]
    where: 'articleWhereInput'
    cursor: 'articleWhereUniqueInput'
    distinct: List['articleScalarFieldKeys']
    include: 'articleIncludeFromarticleRecursive3'


class FindManyarticleArgsFromcategoryRecursive3(TypedDict, total=False):
    """Arguments for category"""
    take: int
    skip: int
    order_by: Union['articleOrderByInput', List['articleOrderByInput']]
    where: 'articleWhereInput'
    cursor: 'articleWhereUniqueInput'
    distinct: List['articleScalarFieldKeys']
    include: 'articleIncludeFromarticleRecursive4'


class FindManyarticleArgsFromcategoryRecursive4(TypedDict, total=False):
    """Arguments for category"""
    take: int
    skip: int
    order_by: Union['articleOrderByInput', List['articleOrderByInput']]
    where: 'articleWhereInput'
    cursor: 'articleWhereUniqueInput'
    distinct: List['articleScalarFieldKeys']
    
    

class categoryIncludeFromcategory(TypedDict, total=False):
    """Relational arguments for category"""
    articles: Union[bool, 'FindManycategory_to_articleArgsFromcategoryRecursive1']


class categoryIncludeFromcategoryRecursive1(TypedDict, total=False):
    """Relational arguments for category"""
    articles: Union[bool, 'FindManycategory_to_articleArgsFromcategoryRecursive2']


class categoryIncludeFromcategoryRecursive2(TypedDict, total=False):
    """Relational arguments for category"""
    articles: Union[bool, 'FindManycategory_to_articleArgsFromcategoryRecursive3']


class categoryIncludeFromcategoryRecursive3(TypedDict, total=False):
    """Relational arguments for category"""
    articles: Union[bool, 'FindManycategory_to_articleArgsFromcategoryRecursive4']


class categoryIncludeFromcategoryRecursive4(TypedDict, total=False):
    """Relational arguments for category"""

    

class categoryArgsFromcategory(TypedDict, total=False):
    """Arguments for category"""
    include: 'categoryIncludeFromcategoryRecursive1'


class categoryArgsFromcategoryRecursive1(TypedDict, total=False):
    """Arguments for category"""
    include: 'categoryIncludeFromcategoryRecursive2'


class categoryArgsFromcategoryRecursive2(TypedDict, total=False):
    """Arguments for category"""
    include: 'categoryIncludeFromcategoryRecursive3'


class categoryArgsFromcategoryRecursive3(TypedDict, total=False):
    """Arguments for category"""
    include: 'categoryIncludeFromcategoryRecursive4'


class categoryArgsFromcategoryRecursive4(TypedDict, total=False):
    """Arguments for category"""
    
    

class FindManycategoryArgsFromcategory(TypedDict, total=False):
    """Arguments for category"""
    take: int
    skip: int
    order_by: Union['categoryOrderByInput', List['categoryOrderByInput']]
    where: 'categoryWhereInput'
    cursor: 'categoryWhereUniqueInput'
    distinct: List['categoryScalarFieldKeys']
    include: 'categoryIncludeFromcategoryRecursive1'


class FindManycategoryArgsFromcategoryRecursive1(TypedDict, total=False):
    """Arguments for category"""
    take: int
    skip: int
    order_by: Union['categoryOrderByInput', List['categoryOrderByInput']]
    where: 'categoryWhereInput'
    cursor: 'categoryWhereUniqueInput'
    distinct: List['categoryScalarFieldKeys']
    include: 'categoryIncludeFromcategoryRecursive2'


class FindManycategoryArgsFromcategoryRecursive2(TypedDict, total=False):
    """Arguments for category"""
    take: int
    skip: int
    order_by: Union['categoryOrderByInput', List['categoryOrderByInput']]
    where: 'categoryWhereInput'
    cursor: 'categoryWhereUniqueInput'
    distinct: List['categoryScalarFieldKeys']
    include: 'categoryIncludeFromcategoryRecursive3'


class FindManycategoryArgsFromcategoryRecursive3(TypedDict, total=False):
    """Arguments for category"""
    take: int
    skip: int
    order_by: Union['categoryOrderByInput', List['categoryOrderByInput']]
    where: 'categoryWhereInput'
    cursor: 'categoryWhereUniqueInput'
    distinct: List['categoryScalarFieldKeys']
    include: 'categoryIncludeFromcategoryRecursive4'


class FindManycategoryArgsFromcategoryRecursive4(TypedDict, total=False):
    """Arguments for category"""
    take: int
    skip: int
    order_by: Union['categoryOrderByInput', List['categoryOrderByInput']]
    where: 'categoryWhereInput'
    cursor: 'categoryWhereUniqueInput'
    distinct: List['categoryScalarFieldKeys']
    
    

class category_to_articleIncludeFromcategory(TypedDict, total=False):
    """Relational arguments for category"""
    article: Union[bool, 'articleArgsFromcategoryRecursive1']
    category: Union[bool, 'categoryArgsFromcategoryRecursive1']


class category_to_articleIncludeFromcategoryRecursive1(TypedDict, total=False):
    """Relational arguments for category"""
    article: Union[bool, 'articleArgsFromcategoryRecursive2']
    category: Union[bool, 'categoryArgsFromcategoryRecursive2']


class category_to_articleIncludeFromcategoryRecursive2(TypedDict, total=False):
    """Relational arguments for category"""
    article: Union[bool, 'articleArgsFromcategoryRecursive3']
    category: Union[bool, 'categoryArgsFromcategoryRecursive3']


class category_to_articleIncludeFromcategoryRecursive3(TypedDict, total=False):
    """Relational arguments for category"""
    article: Union[bool, 'articleArgsFromcategoryRecursive4']
    category: Union[bool, 'categoryArgsFromcategoryRecursive4']


class category_to_articleIncludeFromcategoryRecursive4(TypedDict, total=False):
    """Relational arguments for category"""

    

class category_to_articleArgsFromcategory(TypedDict, total=False):
    """Arguments for category"""
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive1'


class category_to_articleArgsFromcategoryRecursive1(TypedDict, total=False):
    """Arguments for category"""
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive2'


class category_to_articleArgsFromcategoryRecursive2(TypedDict, total=False):
    """Arguments for category"""
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive3'


class category_to_articleArgsFromcategoryRecursive3(TypedDict, total=False):
    """Arguments for category"""
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive4'


class category_to_articleArgsFromcategoryRecursive4(TypedDict, total=False):
    """Arguments for category"""
    
    

class FindManycategory_to_articleArgsFromcategory(TypedDict, total=False):
    """Arguments for category"""
    take: int
    skip: int
    order_by: Union['category_to_articleOrderByInput', List['category_to_articleOrderByInput']]
    where: 'category_to_articleWhereInput'
    cursor: 'category_to_articleWhereUniqueInput'
    distinct: List['category_to_articleScalarFieldKeys']
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive1'


class FindManycategory_to_articleArgsFromcategoryRecursive1(TypedDict, total=False):
    """Arguments for category"""
    take: int
    skip: int
    order_by: Union['category_to_articleOrderByInput', List['category_to_articleOrderByInput']]
    where: 'category_to_articleWhereInput'
    cursor: 'category_to_articleWhereUniqueInput'
    distinct: List['category_to_articleScalarFieldKeys']
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive2'


class FindManycategory_to_articleArgsFromcategoryRecursive2(TypedDict, total=False):
    """Arguments for category"""
    take: int
    skip: int
    order_by: Union['category_to_articleOrderByInput', List['category_to_articleOrderByInput']]
    where: 'category_to_articleWhereInput'
    cursor: 'category_to_articleWhereUniqueInput'
    distinct: List['category_to_articleScalarFieldKeys']
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive3'


class FindManycategory_to_articleArgsFromcategoryRecursive3(TypedDict, total=False):
    """Arguments for category"""
    take: int
    skip: int
    order_by: Union['category_to_articleOrderByInput', List['category_to_articleOrderByInput']]
    where: 'category_to_articleWhereInput'
    cursor: 'category_to_articleWhereUniqueInput'
    distinct: List['category_to_articleScalarFieldKeys']
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive4'


class FindManycategory_to_articleArgsFromcategoryRecursive4(TypedDict, total=False):
    """Arguments for category"""
    take: int
    skip: int
    order_by: Union['category_to_articleOrderByInput', List['category_to_articleOrderByInput']]
    where: 'category_to_articleWhereInput'
    cursor: 'category_to_articleWhereUniqueInput'
    distinct: List['category_to_articleScalarFieldKeys']
    
    

class commentIncludeFromcategory(TypedDict, total=False):
    """Relational arguments for category"""
    article: Union[bool, 'articleArgsFromcategoryRecursive1']
    user: Union[bool, 'userArgsFromcategoryRecursive1']


class commentIncludeFromcategoryRecursive1(TypedDict, total=False):
    """Relational arguments for category"""
    article: Union[bool, 'articleArgsFromcategoryRecursive2']
    user: Union[bool, 'userArgsFromcategoryRecursive2']


class commentIncludeFromcategoryRecursive2(TypedDict, total=False):
    """Relational arguments for category"""
    article: Union[bool, 'articleArgsFromcategoryRecursive3']
    user: Union[bool, 'userArgsFromcategoryRecursive3']


class commentIncludeFromcategoryRecursive3(TypedDict, total=False):
    """Relational arguments for category"""
    article: Union[bool, 'articleArgsFromcategoryRecursive4']
    user: Union[bool, 'userArgsFromcategoryRecursive4']


class commentIncludeFromcategoryRecursive4(TypedDict, total=False):
    """Relational arguments for category"""

    

class commentArgsFromcategory(TypedDict, total=False):
    """Arguments for category"""
    include: 'commentIncludeFromcommentRecursive1'


class commentArgsFromcategoryRecursive1(TypedDict, total=False):
    """Arguments for category"""
    include: 'commentIncludeFromcommentRecursive2'


class commentArgsFromcategoryRecursive2(TypedDict, total=False):
    """Arguments for category"""
    include: 'commentIncludeFromcommentRecursive3'


class commentArgsFromcategoryRecursive3(TypedDict, total=False):
    """Arguments for category"""
    include: 'commentIncludeFromcommentRecursive4'


class commentArgsFromcategoryRecursive4(TypedDict, total=False):
    """Arguments for category"""
    
    

class FindManycommentArgsFromcategory(TypedDict, total=False):
    """Arguments for category"""
    take: int
    skip: int
    order_by: Union['commentOrderByInput', List['commentOrderByInput']]
    where: 'commentWhereInput'
    cursor: 'commentWhereUniqueInput'
    distinct: List['commentScalarFieldKeys']
    include: 'commentIncludeFromcommentRecursive1'


class FindManycommentArgsFromcategoryRecursive1(TypedDict, total=False):
    """Arguments for category"""
    take: int
    skip: int
    order_by: Union['commentOrderByInput', List['commentOrderByInput']]
    where: 'commentWhereInput'
    cursor: 'commentWhereUniqueInput'
    distinct: List['commentScalarFieldKeys']
    include: 'commentIncludeFromcommentRecursive2'


class FindManycommentArgsFromcategoryRecursive2(TypedDict, total=False):
    """Arguments for category"""
    take: int
    skip: int
    order_by: Union['commentOrderByInput', List['commentOrderByInput']]
    where: 'commentWhereInput'
    cursor: 'commentWhereUniqueInput'
    distinct: List['commentScalarFieldKeys']
    include: 'commentIncludeFromcommentRecursive3'


class FindManycommentArgsFromcategoryRecursive3(TypedDict, total=False):
    """Arguments for category"""
    take: int
    skip: int
    order_by: Union['commentOrderByInput', List['commentOrderByInput']]
    where: 'commentWhereInput'
    cursor: 'commentWhereUniqueInput'
    distinct: List['commentScalarFieldKeys']
    include: 'commentIncludeFromcommentRecursive4'


class FindManycommentArgsFromcategoryRecursive4(TypedDict, total=False):
    """Arguments for category"""
    take: int
    skip: int
    order_by: Union['commentOrderByInput', List['commentOrderByInput']]
    where: 'commentWhereInput'
    cursor: 'commentWhereUniqueInput'
    distinct: List['commentScalarFieldKeys']
    
    

class likeIncludeFromcategory(TypedDict, total=False):
    """Relational arguments for category"""
    article: Union[bool, 'articleArgsFromcategoryRecursive1']
    user: Union[bool, 'userArgsFromcategoryRecursive1']


class likeIncludeFromcategoryRecursive1(TypedDict, total=False):
    """Relational arguments for category"""
    article: Union[bool, 'articleArgsFromcategoryRecursive2']
    user: Union[bool, 'userArgsFromcategoryRecursive2']


class likeIncludeFromcategoryRecursive2(TypedDict, total=False):
    """Relational arguments for category"""
    article: Union[bool, 'articleArgsFromcategoryRecursive3']
    user: Union[bool, 'userArgsFromcategoryRecursive3']


class likeIncludeFromcategoryRecursive3(TypedDict, total=False):
    """Relational arguments for category"""
    article: Union[bool, 'articleArgsFromcategoryRecursive4']
    user: Union[bool, 'userArgsFromcategoryRecursive4']


class likeIncludeFromcategoryRecursive4(TypedDict, total=False):
    """Relational arguments for category"""

    

class likeArgsFromcategory(TypedDict, total=False):
    """Arguments for category"""
    include: 'likeIncludeFromlikeRecursive1'


class likeArgsFromcategoryRecursive1(TypedDict, total=False):
    """Arguments for category"""
    include: 'likeIncludeFromlikeRecursive2'


class likeArgsFromcategoryRecursive2(TypedDict, total=False):
    """Arguments for category"""
    include: 'likeIncludeFromlikeRecursive3'


class likeArgsFromcategoryRecursive3(TypedDict, total=False):
    """Arguments for category"""
    include: 'likeIncludeFromlikeRecursive4'


class likeArgsFromcategoryRecursive4(TypedDict, total=False):
    """Arguments for category"""
    
    

class FindManylikeArgsFromcategory(TypedDict, total=False):
    """Arguments for category"""
    take: int
    skip: int
    order_by: Union['likeOrderByInput', List['likeOrderByInput']]
    where: 'likeWhereInput'
    cursor: 'likeWhereUniqueInput'
    distinct: List['likeScalarFieldKeys']
    include: 'likeIncludeFromlikeRecursive1'


class FindManylikeArgsFromcategoryRecursive1(TypedDict, total=False):
    """Arguments for category"""
    take: int
    skip: int
    order_by: Union['likeOrderByInput', List['likeOrderByInput']]
    where: 'likeWhereInput'
    cursor: 'likeWhereUniqueInput'
    distinct: List['likeScalarFieldKeys']
    include: 'likeIncludeFromlikeRecursive2'


class FindManylikeArgsFromcategoryRecursive2(TypedDict, total=False):
    """Arguments for category"""
    take: int
    skip: int
    order_by: Union['likeOrderByInput', List['likeOrderByInput']]
    where: 'likeWhereInput'
    cursor: 'likeWhereUniqueInput'
    distinct: List['likeScalarFieldKeys']
    include: 'likeIncludeFromlikeRecursive3'


class FindManylikeArgsFromcategoryRecursive3(TypedDict, total=False):
    """Arguments for category"""
    take: int
    skip: int
    order_by: Union['likeOrderByInput', List['likeOrderByInput']]
    where: 'likeWhereInput'
    cursor: 'likeWhereUniqueInput'
    distinct: List['likeScalarFieldKeys']
    include: 'likeIncludeFromlikeRecursive4'


class FindManylikeArgsFromcategoryRecursive4(TypedDict, total=False):
    """Arguments for category"""
    take: int
    skip: int
    order_by: Union['likeOrderByInput', List['likeOrderByInput']]
    where: 'likeWhereInput'
    cursor: 'likeWhereUniqueInput'
    distinct: List['likeScalarFieldKeys']
    
    

class fileIncludeFromcategory(TypedDict, total=False):
    """Relational arguments for category"""
    article: Union[bool, 'articleArgsFromcategoryRecursive1']


class fileIncludeFromcategoryRecursive1(TypedDict, total=False):
    """Relational arguments for category"""
    article: Union[bool, 'articleArgsFromcategoryRecursive2']


class fileIncludeFromcategoryRecursive2(TypedDict, total=False):
    """Relational arguments for category"""
    article: Union[bool, 'articleArgsFromcategoryRecursive3']


class fileIncludeFromcategoryRecursive3(TypedDict, total=False):
    """Relational arguments for category"""
    article: Union[bool, 'articleArgsFromcategoryRecursive4']


class fileIncludeFromcategoryRecursive4(TypedDict, total=False):
    """Relational arguments for category"""

    

class fileArgsFromcategory(TypedDict, total=False):
    """Arguments for category"""
    include: 'fileIncludeFromfileRecursive1'


class fileArgsFromcategoryRecursive1(TypedDict, total=False):
    """Arguments for category"""
    include: 'fileIncludeFromfileRecursive2'


class fileArgsFromcategoryRecursive2(TypedDict, total=False):
    """Arguments for category"""
    include: 'fileIncludeFromfileRecursive3'


class fileArgsFromcategoryRecursive3(TypedDict, total=False):
    """Arguments for category"""
    include: 'fileIncludeFromfileRecursive4'


class fileArgsFromcategoryRecursive4(TypedDict, total=False):
    """Arguments for category"""
    
    

class FindManyfileArgsFromcategory(TypedDict, total=False):
    """Arguments for category"""
    take: int
    skip: int
    order_by: Union['fileOrderByInput', List['fileOrderByInput']]
    where: 'fileWhereInput'
    cursor: 'fileWhereUniqueInput'
    distinct: List['fileScalarFieldKeys']
    include: 'fileIncludeFromfileRecursive1'


class FindManyfileArgsFromcategoryRecursive1(TypedDict, total=False):
    """Arguments for category"""
    take: int
    skip: int
    order_by: Union['fileOrderByInput', List['fileOrderByInput']]
    where: 'fileWhereInput'
    cursor: 'fileWhereUniqueInput'
    distinct: List['fileScalarFieldKeys']
    include: 'fileIncludeFromfileRecursive2'


class FindManyfileArgsFromcategoryRecursive2(TypedDict, total=False):
    """Arguments for category"""
    take: int
    skip: int
    order_by: Union['fileOrderByInput', List['fileOrderByInput']]
    where: 'fileWhereInput'
    cursor: 'fileWhereUniqueInput'
    distinct: List['fileScalarFieldKeys']
    include: 'fileIncludeFromfileRecursive3'


class FindManyfileArgsFromcategoryRecursive3(TypedDict, total=False):
    """Arguments for category"""
    take: int
    skip: int
    order_by: Union['fileOrderByInput', List['fileOrderByInput']]
    where: 'fileWhereInput'
    cursor: 'fileWhereUniqueInput'
    distinct: List['fileScalarFieldKeys']
    include: 'fileIncludeFromfileRecursive4'


class FindManyfileArgsFromcategoryRecursive4(TypedDict, total=False):
    """Arguments for category"""
    take: int
    skip: int
    order_by: Union['fileOrderByInput', List['fileOrderByInput']]
    where: 'fileWhereInput'
    cursor: 'fileWhereUniqueInput'
    distinct: List['fileScalarFieldKeys']
    


FindManycategoryArgs = FindManycategoryArgsFromcategory
FindFirstcategoryArgs = FindManycategoryArgsFromcategory


    

class categoryWhereInput(TypedDict, total=False):
    """category arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    articles: 'category_to_articleListRelationFilter'

    # should be noted that AND and NOT should be Union['categoryWhereInputRecursive1', List['categoryWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['categoryWhereInputRecursive1']
    OR: List['categoryWhereInputRecursive1']
    NOT: List['categoryWhereInputRecursive1']


class categoryWhereInputRecursive1(TypedDict, total=False):
    """category arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    articles: 'category_to_articleListRelationFilter'

    # should be noted that AND and NOT should be Union['categoryWhereInputRecursive2', List['categoryWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['categoryWhereInputRecursive2']
    OR: List['categoryWhereInputRecursive2']
    NOT: List['categoryWhereInputRecursive2']


class categoryWhereInputRecursive2(TypedDict, total=False):
    """category arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    articles: 'category_to_articleListRelationFilter'

    # should be noted that AND and NOT should be Union['categoryWhereInputRecursive3', List['categoryWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['categoryWhereInputRecursive3']
    OR: List['categoryWhereInputRecursive3']
    NOT: List['categoryWhereInputRecursive3']


class categoryWhereInputRecursive3(TypedDict, total=False):
    """category arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    articles: 'category_to_articleListRelationFilter'

    # should be noted that AND and NOT should be Union['categoryWhereInputRecursive4', List['categoryWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['categoryWhereInputRecursive4']
    OR: List['categoryWhereInputRecursive4']
    NOT: List['categoryWhereInputRecursive4']


class categoryWhereInputRecursive4(TypedDict, total=False):
    """category arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    articles: 'category_to_articleListRelationFilter'



# aggregate category types


    

class categoryScalarWhereWithAggregatesInput(TypedDict, total=False):
    """category arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['categoryScalarWhereWithAggregatesInputRecursive1']
    OR: List['categoryScalarWhereWithAggregatesInputRecursive1']
    NOT: List['categoryScalarWhereWithAggregatesInputRecursive1']


class categoryScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """category arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['categoryScalarWhereWithAggregatesInputRecursive2']
    OR: List['categoryScalarWhereWithAggregatesInputRecursive2']
    NOT: List['categoryScalarWhereWithAggregatesInputRecursive2']


class categoryScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """category arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['categoryScalarWhereWithAggregatesInputRecursive3']
    OR: List['categoryScalarWhereWithAggregatesInputRecursive3']
    NOT: List['categoryScalarWhereWithAggregatesInputRecursive3']


class categoryScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """category arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['categoryScalarWhereWithAggregatesInputRecursive4']
    OR: List['categoryScalarWhereWithAggregatesInputRecursive4']
    NOT: List['categoryScalarWhereWithAggregatesInputRecursive4']


class categoryScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """category arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']



class categoryGroupByOutput(TypedDict, total=False):
    id: _int
    name: _str
    _sum: 'categorySumAggregateOutput'
    _avg: 'categoryAvgAggregateOutput'
    _min: 'categoryMinAggregateOutput'
    _max: 'categoryMaxAggregateOutput'
    _count: 'categoryCountAggregateOutput'


class categoryAvgAggregateOutput(TypedDict, total=False):
    """category output for aggregating averages"""
    id: float


class categorySumAggregateOutput(TypedDict, total=False):
    """category output for aggregating sums"""
    id: _int


class categoryScalarAggregateOutput(TypedDict, total=False):
    """category output including scalar fields"""
    id: _int
    name: _str


categoryMinAggregateOutput = categoryScalarAggregateOutput
categoryMaxAggregateOutput = categoryScalarAggregateOutput


class categoryMaxAggregateInput(TypedDict, total=False):
    """category input for aggregating by max"""
    id: bool
    name: bool


class categoryMinAggregateInput(TypedDict, total=False):
    """category input for aggregating by min"""
    id: bool
    name: bool


class categoryNumberAggregateInput(TypedDict, total=False):
    """category input for aggregating numbers"""
    id: bool


categoryAvgAggregateInput = categoryNumberAggregateInput
categorySumAggregateInput = categoryNumberAggregateInput


categoryCountAggregateInput = TypedDict(
    'categoryCountAggregateInput',
    {
        'id': bool,
        'name': bool,
        '_all': bool,
    },
    total=False,
)

categoryCountAggregateOutput = TypedDict(
    'categoryCountAggregateOutput',
    {
        'id': int,
        'name': int,
        '_all': int,
    },
    total=False,
)


categoryKeys = Literal[
    'id',
    'name',
    'articles',
]
categoryScalarFieldKeys = Literal[
    'id',
    'name',
]
categoryScalarFieldKeysT = TypeVar('categoryScalarFieldKeysT', bound=categoryScalarFieldKeys)

categoryRelationalFieldKeys = Literal[
        'articles',
    ]

# category_to_article types

class category_to_articleOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the category_to_article create method"""
    article_id: _int
    category_id: _int
    article: 'articleCreateNestedWithoutRelationsInput'
    category: 'categoryCreateNestedWithoutRelationsInput'


class category_to_articleCreateInput(category_to_articleOptionalCreateInput):
    """Required arguments to the category_to_article create method"""


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class category_to_articleOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the category_to_article create method, without relations"""
    article_id: _int
    category_id: _int


class category_to_articleCreateWithoutRelationsInput(category_to_articleOptionalCreateWithoutRelationsInput):
    """Required arguments to the category_to_article create method, without relations"""

class category_to_articleConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'category_to_articleCreateWithoutRelationsInput'
    where: 'category_to_articleWhereUniqueInput'

class category_to_articleCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'category_to_articleCreateWithoutRelationsInput'
    connect: 'category_to_articleWhereUniqueInput'
    connect_or_create: 'category_to_articleConnectOrCreateWithoutRelationsInput'


class category_to_articleCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['category_to_articleCreateWithoutRelationsInput', List['category_to_articleCreateWithoutRelationsInput']]
    connect: Union['category_to_articleWhereUniqueInput', List['category_to_articleWhereUniqueInput']]
    connect_or_create: Union['category_to_articleConnectOrCreateWithoutRelationsInput', List['category_to_articleConnectOrCreateWithoutRelationsInput']]

_category_to_articleCompoundPrimaryKeyInner = TypedDict(
    '_category_to_articleCompoundPrimaryKeyInner',
    {
        'article_id': '_int',
        'category_id': '_int',
    },
    total=True
)

_category_to_articleCompoundPrimaryKey = TypedDict(
    '_category_to_articleCompoundPrimaryKey',
    {
        'article_id_category_id': '_category_to_articleCompoundPrimaryKeyInner',
    },
    total=True
)

category_to_articleWhereUniqueInput = _category_to_articleCompoundPrimaryKey


class category_to_articleUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    article: 'articleUpdateOneWithoutRelationsInput'
    category: 'categoryUpdateOneWithoutRelationsInput'


class category_to_articleUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""


class category_to_articleUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['category_to_articleCreateWithoutRelationsInput']
    connect: List['category_to_articleWhereUniqueInput']
    connect_or_create: List['category_to_articleConnectOrCreateWithoutRelationsInput']
    set: List['category_to_articleWhereUniqueInput']
    disconnect: List['category_to_articleWhereUniqueInput']
    delete: List['category_to_articleWhereUniqueInput']

    # TODO
    # update: List['category_to_articleUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['category_to_articleUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['category_to_articleScalarWhereInput']
    # upsert: List['category_to_articleUpserteWithWhereUniqueWithoutRelationsInput']


class category_to_articleUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'category_to_articleCreateWithoutRelationsInput'
    connect: 'category_to_articleWhereUniqueInput'
    connect_or_create: 'category_to_articleConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'category_to_articleUpdateInput'
    # upsert: 'category_to_articleUpsertWithoutRelationsInput'


class category_to_articleUpsertInput(TypedDict):
    create: 'category_to_articleCreateInput'
    update: 'category_to_articleUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_category_to_article_article_id_OrderByInput = TypedDict(
    '_category_to_article_article_id_OrderByInput',
    {
        'article_id': 'SortOrder',
    },
    total=True
)

_category_to_article_category_id_OrderByInput = TypedDict(
    '_category_to_article_category_id_OrderByInput',
    {
        'category_id': 'SortOrder',
    },
    total=True
)

_category_to_article_RelevanceInner = TypedDict(
    '_category_to_article_RelevanceInner',
    {
        'fields': 'List[category_to_articleScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_category_to_article_RelevanceOrderByInput = TypedDict(
    '_category_to_article_RelevanceOrderByInput',
    {
        '_relevance': '_category_to_article_RelevanceInner',
    },
    total=True
)

category_to_articleOrderByInput = Union[
    '_category_to_article_article_id_OrderByInput',
    '_category_to_article_category_id_OrderByInput',
    '_category_to_article_RelevanceOrderByInput',
]



# recursive category_to_article types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

category_to_articleRelationFilter = TypedDict(
    'category_to_articleRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class category_to_articleListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class category_to_articleInclude(TypedDict, total=False):
    """category_to_article relational arguments"""
    article: Union[bool, 'articleArgsFromcategory_to_article']
    category: Union[bool, 'categoryArgsFromcategory_to_article']


    

class userIncludeFromcategory_to_article(TypedDict, total=False):
    """Relational arguments for category_to_article"""
    articles: Union[bool, 'FindManyarticleArgsFromcategory_to_articleRecursive1']
    comments: Union[bool, 'FindManycommentArgsFromcategory_to_articleRecursive1']
    likes: Union[bool, 'FindManylikeArgsFromcategory_to_articleRecursive1']


class userIncludeFromcategory_to_articleRecursive1(TypedDict, total=False):
    """Relational arguments for category_to_article"""
    articles: Union[bool, 'FindManyarticleArgsFromcategory_to_articleRecursive2']
    comments: Union[bool, 'FindManycommentArgsFromcategory_to_articleRecursive2']
    likes: Union[bool, 'FindManylikeArgsFromcategory_to_articleRecursive2']


class userIncludeFromcategory_to_articleRecursive2(TypedDict, total=False):
    """Relational arguments for category_to_article"""
    articles: Union[bool, 'FindManyarticleArgsFromcategory_to_articleRecursive3']
    comments: Union[bool, 'FindManycommentArgsFromcategory_to_articleRecursive3']
    likes: Union[bool, 'FindManylikeArgsFromcategory_to_articleRecursive3']


class userIncludeFromcategory_to_articleRecursive3(TypedDict, total=False):
    """Relational arguments for category_to_article"""
    articles: Union[bool, 'FindManyarticleArgsFromcategory_to_articleRecursive4']
    comments: Union[bool, 'FindManycommentArgsFromcategory_to_articleRecursive4']
    likes: Union[bool, 'FindManylikeArgsFromcategory_to_articleRecursive4']


class userIncludeFromcategory_to_articleRecursive4(TypedDict, total=False):
    """Relational arguments for category_to_article"""

    

class userArgsFromcategory_to_article(TypedDict, total=False):
    """Arguments for category_to_article"""
    include: 'userIncludeFromuserRecursive1'


class userArgsFromcategory_to_articleRecursive1(TypedDict, total=False):
    """Arguments for category_to_article"""
    include: 'userIncludeFromuserRecursive2'


class userArgsFromcategory_to_articleRecursive2(TypedDict, total=False):
    """Arguments for category_to_article"""
    include: 'userIncludeFromuserRecursive3'


class userArgsFromcategory_to_articleRecursive3(TypedDict, total=False):
    """Arguments for category_to_article"""
    include: 'userIncludeFromuserRecursive4'


class userArgsFromcategory_to_articleRecursive4(TypedDict, total=False):
    """Arguments for category_to_article"""
    
    

class FindManyuserArgsFromcategory_to_article(TypedDict, total=False):
    """Arguments for category_to_article"""
    take: int
    skip: int
    order_by: Union['userOrderByInput', List['userOrderByInput']]
    where: 'userWhereInput'
    cursor: 'userWhereUniqueInput'
    distinct: List['userScalarFieldKeys']
    include: 'userIncludeFromuserRecursive1'


class FindManyuserArgsFromcategory_to_articleRecursive1(TypedDict, total=False):
    """Arguments for category_to_article"""
    take: int
    skip: int
    order_by: Union['userOrderByInput', List['userOrderByInput']]
    where: 'userWhereInput'
    cursor: 'userWhereUniqueInput'
    distinct: List['userScalarFieldKeys']
    include: 'userIncludeFromuserRecursive2'


class FindManyuserArgsFromcategory_to_articleRecursive2(TypedDict, total=False):
    """Arguments for category_to_article"""
    take: int
    skip: int
    order_by: Union['userOrderByInput', List['userOrderByInput']]
    where: 'userWhereInput'
    cursor: 'userWhereUniqueInput'
    distinct: List['userScalarFieldKeys']
    include: 'userIncludeFromuserRecursive3'


class FindManyuserArgsFromcategory_to_articleRecursive3(TypedDict, total=False):
    """Arguments for category_to_article"""
    take: int
    skip: int
    order_by: Union['userOrderByInput', List['userOrderByInput']]
    where: 'userWhereInput'
    cursor: 'userWhereUniqueInput'
    distinct: List['userScalarFieldKeys']
    include: 'userIncludeFromuserRecursive4'


class FindManyuserArgsFromcategory_to_articleRecursive4(TypedDict, total=False):
    """Arguments for category_to_article"""
    take: int
    skip: int
    order_by: Union['userOrderByInput', List['userOrderByInput']]
    where: 'userWhereInput'
    cursor: 'userWhereUniqueInput'
    distinct: List['userScalarFieldKeys']
    
    

class articleIncludeFromcategory_to_article(TypedDict, total=False):
    """Relational arguments for category_to_article"""
    user: Union[bool, 'userArgsFromcategory_to_articleRecursive1']
    comments: Union[bool, 'FindManycommentArgsFromcategory_to_articleRecursive1']
    likes: Union[bool, 'FindManylikeArgsFromcategory_to_articleRecursive1']
    categories: Union[bool, 'FindManycategory_to_articleArgsFromcategory_to_articleRecursive1']
    files: Union[bool, 'FindManyfileArgsFromcategory_to_articleRecursive1']


class articleIncludeFromcategory_to_articleRecursive1(TypedDict, total=False):
    """Relational arguments for category_to_article"""
    user: Union[bool, 'userArgsFromcategory_to_articleRecursive2']
    comments: Union[bool, 'FindManycommentArgsFromcategory_to_articleRecursive2']
    likes: Union[bool, 'FindManylikeArgsFromcategory_to_articleRecursive2']
    categories: Union[bool, 'FindManycategory_to_articleArgsFromcategory_to_articleRecursive2']
    files: Union[bool, 'FindManyfileArgsFromcategory_to_articleRecursive2']


class articleIncludeFromcategory_to_articleRecursive2(TypedDict, total=False):
    """Relational arguments for category_to_article"""
    user: Union[bool, 'userArgsFromcategory_to_articleRecursive3']
    comments: Union[bool, 'FindManycommentArgsFromcategory_to_articleRecursive3']
    likes: Union[bool, 'FindManylikeArgsFromcategory_to_articleRecursive3']
    categories: Union[bool, 'FindManycategory_to_articleArgsFromcategory_to_articleRecursive3']
    files: Union[bool, 'FindManyfileArgsFromcategory_to_articleRecursive3']


class articleIncludeFromcategory_to_articleRecursive3(TypedDict, total=False):
    """Relational arguments for category_to_article"""
    user: Union[bool, 'userArgsFromcategory_to_articleRecursive4']
    comments: Union[bool, 'FindManycommentArgsFromcategory_to_articleRecursive4']
    likes: Union[bool, 'FindManylikeArgsFromcategory_to_articleRecursive4']
    categories: Union[bool, 'FindManycategory_to_articleArgsFromcategory_to_articleRecursive4']
    files: Union[bool, 'FindManyfileArgsFromcategory_to_articleRecursive4']


class articleIncludeFromcategory_to_articleRecursive4(TypedDict, total=False):
    """Relational arguments for category_to_article"""

    

class articleArgsFromcategory_to_article(TypedDict, total=False):
    """Arguments for category_to_article"""
    include: 'articleIncludeFromarticleRecursive1'


class articleArgsFromcategory_to_articleRecursive1(TypedDict, total=False):
    """Arguments for category_to_article"""
    include: 'articleIncludeFromarticleRecursive2'


class articleArgsFromcategory_to_articleRecursive2(TypedDict, total=False):
    """Arguments for category_to_article"""
    include: 'articleIncludeFromarticleRecursive3'


class articleArgsFromcategory_to_articleRecursive3(TypedDict, total=False):
    """Arguments for category_to_article"""
    include: 'articleIncludeFromarticleRecursive4'


class articleArgsFromcategory_to_articleRecursive4(TypedDict, total=False):
    """Arguments for category_to_article"""
    
    

class FindManyarticleArgsFromcategory_to_article(TypedDict, total=False):
    """Arguments for category_to_article"""
    take: int
    skip: int
    order_by: Union['articleOrderByInput', List['articleOrderByInput']]
    where: 'articleWhereInput'
    cursor: 'articleWhereUniqueInput'
    distinct: List['articleScalarFieldKeys']
    include: 'articleIncludeFromarticleRecursive1'


class FindManyarticleArgsFromcategory_to_articleRecursive1(TypedDict, total=False):
    """Arguments for category_to_article"""
    take: int
    skip: int
    order_by: Union['articleOrderByInput', List['articleOrderByInput']]
    where: 'articleWhereInput'
    cursor: 'articleWhereUniqueInput'
    distinct: List['articleScalarFieldKeys']
    include: 'articleIncludeFromarticleRecursive2'


class FindManyarticleArgsFromcategory_to_articleRecursive2(TypedDict, total=False):
    """Arguments for category_to_article"""
    take: int
    skip: int
    order_by: Union['articleOrderByInput', List['articleOrderByInput']]
    where: 'articleWhereInput'
    cursor: 'articleWhereUniqueInput'
    distinct: List['articleScalarFieldKeys']
    include: 'articleIncludeFromarticleRecursive3'


class FindManyarticleArgsFromcategory_to_articleRecursive3(TypedDict, total=False):
    """Arguments for category_to_article"""
    take: int
    skip: int
    order_by: Union['articleOrderByInput', List['articleOrderByInput']]
    where: 'articleWhereInput'
    cursor: 'articleWhereUniqueInput'
    distinct: List['articleScalarFieldKeys']
    include: 'articleIncludeFromarticleRecursive4'


class FindManyarticleArgsFromcategory_to_articleRecursive4(TypedDict, total=False):
    """Arguments for category_to_article"""
    take: int
    skip: int
    order_by: Union['articleOrderByInput', List['articleOrderByInput']]
    where: 'articleWhereInput'
    cursor: 'articleWhereUniqueInput'
    distinct: List['articleScalarFieldKeys']
    
    

class categoryIncludeFromcategory_to_article(TypedDict, total=False):
    """Relational arguments for category_to_article"""
    articles: Union[bool, 'FindManycategory_to_articleArgsFromcategory_to_articleRecursive1']


class categoryIncludeFromcategory_to_articleRecursive1(TypedDict, total=False):
    """Relational arguments for category_to_article"""
    articles: Union[bool, 'FindManycategory_to_articleArgsFromcategory_to_articleRecursive2']


class categoryIncludeFromcategory_to_articleRecursive2(TypedDict, total=False):
    """Relational arguments for category_to_article"""
    articles: Union[bool, 'FindManycategory_to_articleArgsFromcategory_to_articleRecursive3']


class categoryIncludeFromcategory_to_articleRecursive3(TypedDict, total=False):
    """Relational arguments for category_to_article"""
    articles: Union[bool, 'FindManycategory_to_articleArgsFromcategory_to_articleRecursive4']


class categoryIncludeFromcategory_to_articleRecursive4(TypedDict, total=False):
    """Relational arguments for category_to_article"""

    

class categoryArgsFromcategory_to_article(TypedDict, total=False):
    """Arguments for category_to_article"""
    include: 'categoryIncludeFromcategoryRecursive1'


class categoryArgsFromcategory_to_articleRecursive1(TypedDict, total=False):
    """Arguments for category_to_article"""
    include: 'categoryIncludeFromcategoryRecursive2'


class categoryArgsFromcategory_to_articleRecursive2(TypedDict, total=False):
    """Arguments for category_to_article"""
    include: 'categoryIncludeFromcategoryRecursive3'


class categoryArgsFromcategory_to_articleRecursive3(TypedDict, total=False):
    """Arguments for category_to_article"""
    include: 'categoryIncludeFromcategoryRecursive4'


class categoryArgsFromcategory_to_articleRecursive4(TypedDict, total=False):
    """Arguments for category_to_article"""
    
    

class FindManycategoryArgsFromcategory_to_article(TypedDict, total=False):
    """Arguments for category_to_article"""
    take: int
    skip: int
    order_by: Union['categoryOrderByInput', List['categoryOrderByInput']]
    where: 'categoryWhereInput'
    cursor: 'categoryWhereUniqueInput'
    distinct: List['categoryScalarFieldKeys']
    include: 'categoryIncludeFromcategoryRecursive1'


class FindManycategoryArgsFromcategory_to_articleRecursive1(TypedDict, total=False):
    """Arguments for category_to_article"""
    take: int
    skip: int
    order_by: Union['categoryOrderByInput', List['categoryOrderByInput']]
    where: 'categoryWhereInput'
    cursor: 'categoryWhereUniqueInput'
    distinct: List['categoryScalarFieldKeys']
    include: 'categoryIncludeFromcategoryRecursive2'


class FindManycategoryArgsFromcategory_to_articleRecursive2(TypedDict, total=False):
    """Arguments for category_to_article"""
    take: int
    skip: int
    order_by: Union['categoryOrderByInput', List['categoryOrderByInput']]
    where: 'categoryWhereInput'
    cursor: 'categoryWhereUniqueInput'
    distinct: List['categoryScalarFieldKeys']
    include: 'categoryIncludeFromcategoryRecursive3'


class FindManycategoryArgsFromcategory_to_articleRecursive3(TypedDict, total=False):
    """Arguments for category_to_article"""
    take: int
    skip: int
    order_by: Union['categoryOrderByInput', List['categoryOrderByInput']]
    where: 'categoryWhereInput'
    cursor: 'categoryWhereUniqueInput'
    distinct: List['categoryScalarFieldKeys']
    include: 'categoryIncludeFromcategoryRecursive4'


class FindManycategoryArgsFromcategory_to_articleRecursive4(TypedDict, total=False):
    """Arguments for category_to_article"""
    take: int
    skip: int
    order_by: Union['categoryOrderByInput', List['categoryOrderByInput']]
    where: 'categoryWhereInput'
    cursor: 'categoryWhereUniqueInput'
    distinct: List['categoryScalarFieldKeys']
    
    

class category_to_articleIncludeFromcategory_to_article(TypedDict, total=False):
    """Relational arguments for category_to_article"""
    article: Union[bool, 'articleArgsFromcategory_to_articleRecursive1']
    category: Union[bool, 'categoryArgsFromcategory_to_articleRecursive1']


class category_to_articleIncludeFromcategory_to_articleRecursive1(TypedDict, total=False):
    """Relational arguments for category_to_article"""
    article: Union[bool, 'articleArgsFromcategory_to_articleRecursive2']
    category: Union[bool, 'categoryArgsFromcategory_to_articleRecursive2']


class category_to_articleIncludeFromcategory_to_articleRecursive2(TypedDict, total=False):
    """Relational arguments for category_to_article"""
    article: Union[bool, 'articleArgsFromcategory_to_articleRecursive3']
    category: Union[bool, 'categoryArgsFromcategory_to_articleRecursive3']


class category_to_articleIncludeFromcategory_to_articleRecursive3(TypedDict, total=False):
    """Relational arguments for category_to_article"""
    article: Union[bool, 'articleArgsFromcategory_to_articleRecursive4']
    category: Union[bool, 'categoryArgsFromcategory_to_articleRecursive4']


class category_to_articleIncludeFromcategory_to_articleRecursive4(TypedDict, total=False):
    """Relational arguments for category_to_article"""

    

class category_to_articleArgsFromcategory_to_article(TypedDict, total=False):
    """Arguments for category_to_article"""
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive1'


class category_to_articleArgsFromcategory_to_articleRecursive1(TypedDict, total=False):
    """Arguments for category_to_article"""
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive2'


class category_to_articleArgsFromcategory_to_articleRecursive2(TypedDict, total=False):
    """Arguments for category_to_article"""
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive3'


class category_to_articleArgsFromcategory_to_articleRecursive3(TypedDict, total=False):
    """Arguments for category_to_article"""
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive4'


class category_to_articleArgsFromcategory_to_articleRecursive4(TypedDict, total=False):
    """Arguments for category_to_article"""
    
    

class FindManycategory_to_articleArgsFromcategory_to_article(TypedDict, total=False):
    """Arguments for category_to_article"""
    take: int
    skip: int
    order_by: Union['category_to_articleOrderByInput', List['category_to_articleOrderByInput']]
    where: 'category_to_articleWhereInput'
    cursor: 'category_to_articleWhereUniqueInput'
    distinct: List['category_to_articleScalarFieldKeys']
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive1'


class FindManycategory_to_articleArgsFromcategory_to_articleRecursive1(TypedDict, total=False):
    """Arguments for category_to_article"""
    take: int
    skip: int
    order_by: Union['category_to_articleOrderByInput', List['category_to_articleOrderByInput']]
    where: 'category_to_articleWhereInput'
    cursor: 'category_to_articleWhereUniqueInput'
    distinct: List['category_to_articleScalarFieldKeys']
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive2'


class FindManycategory_to_articleArgsFromcategory_to_articleRecursive2(TypedDict, total=False):
    """Arguments for category_to_article"""
    take: int
    skip: int
    order_by: Union['category_to_articleOrderByInput', List['category_to_articleOrderByInput']]
    where: 'category_to_articleWhereInput'
    cursor: 'category_to_articleWhereUniqueInput'
    distinct: List['category_to_articleScalarFieldKeys']
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive3'


class FindManycategory_to_articleArgsFromcategory_to_articleRecursive3(TypedDict, total=False):
    """Arguments for category_to_article"""
    take: int
    skip: int
    order_by: Union['category_to_articleOrderByInput', List['category_to_articleOrderByInput']]
    where: 'category_to_articleWhereInput'
    cursor: 'category_to_articleWhereUniqueInput'
    distinct: List['category_to_articleScalarFieldKeys']
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive4'


class FindManycategory_to_articleArgsFromcategory_to_articleRecursive4(TypedDict, total=False):
    """Arguments for category_to_article"""
    take: int
    skip: int
    order_by: Union['category_to_articleOrderByInput', List['category_to_articleOrderByInput']]
    where: 'category_to_articleWhereInput'
    cursor: 'category_to_articleWhereUniqueInput'
    distinct: List['category_to_articleScalarFieldKeys']
    
    

class commentIncludeFromcategory_to_article(TypedDict, total=False):
    """Relational arguments for category_to_article"""
    article: Union[bool, 'articleArgsFromcategory_to_articleRecursive1']
    user: Union[bool, 'userArgsFromcategory_to_articleRecursive1']


class commentIncludeFromcategory_to_articleRecursive1(TypedDict, total=False):
    """Relational arguments for category_to_article"""
    article: Union[bool, 'articleArgsFromcategory_to_articleRecursive2']
    user: Union[bool, 'userArgsFromcategory_to_articleRecursive2']


class commentIncludeFromcategory_to_articleRecursive2(TypedDict, total=False):
    """Relational arguments for category_to_article"""
    article: Union[bool, 'articleArgsFromcategory_to_articleRecursive3']
    user: Union[bool, 'userArgsFromcategory_to_articleRecursive3']


class commentIncludeFromcategory_to_articleRecursive3(TypedDict, total=False):
    """Relational arguments for category_to_article"""
    article: Union[bool, 'articleArgsFromcategory_to_articleRecursive4']
    user: Union[bool, 'userArgsFromcategory_to_articleRecursive4']


class commentIncludeFromcategory_to_articleRecursive4(TypedDict, total=False):
    """Relational arguments for category_to_article"""

    

class commentArgsFromcategory_to_article(TypedDict, total=False):
    """Arguments for category_to_article"""
    include: 'commentIncludeFromcommentRecursive1'


class commentArgsFromcategory_to_articleRecursive1(TypedDict, total=False):
    """Arguments for category_to_article"""
    include: 'commentIncludeFromcommentRecursive2'


class commentArgsFromcategory_to_articleRecursive2(TypedDict, total=False):
    """Arguments for category_to_article"""
    include: 'commentIncludeFromcommentRecursive3'


class commentArgsFromcategory_to_articleRecursive3(TypedDict, total=False):
    """Arguments for category_to_article"""
    include: 'commentIncludeFromcommentRecursive4'


class commentArgsFromcategory_to_articleRecursive4(TypedDict, total=False):
    """Arguments for category_to_article"""
    
    

class FindManycommentArgsFromcategory_to_article(TypedDict, total=False):
    """Arguments for category_to_article"""
    take: int
    skip: int
    order_by: Union['commentOrderByInput', List['commentOrderByInput']]
    where: 'commentWhereInput'
    cursor: 'commentWhereUniqueInput'
    distinct: List['commentScalarFieldKeys']
    include: 'commentIncludeFromcommentRecursive1'


class FindManycommentArgsFromcategory_to_articleRecursive1(TypedDict, total=False):
    """Arguments for category_to_article"""
    take: int
    skip: int
    order_by: Union['commentOrderByInput', List['commentOrderByInput']]
    where: 'commentWhereInput'
    cursor: 'commentWhereUniqueInput'
    distinct: List['commentScalarFieldKeys']
    include: 'commentIncludeFromcommentRecursive2'


class FindManycommentArgsFromcategory_to_articleRecursive2(TypedDict, total=False):
    """Arguments for category_to_article"""
    take: int
    skip: int
    order_by: Union['commentOrderByInput', List['commentOrderByInput']]
    where: 'commentWhereInput'
    cursor: 'commentWhereUniqueInput'
    distinct: List['commentScalarFieldKeys']
    include: 'commentIncludeFromcommentRecursive3'


class FindManycommentArgsFromcategory_to_articleRecursive3(TypedDict, total=False):
    """Arguments for category_to_article"""
    take: int
    skip: int
    order_by: Union['commentOrderByInput', List['commentOrderByInput']]
    where: 'commentWhereInput'
    cursor: 'commentWhereUniqueInput'
    distinct: List['commentScalarFieldKeys']
    include: 'commentIncludeFromcommentRecursive4'


class FindManycommentArgsFromcategory_to_articleRecursive4(TypedDict, total=False):
    """Arguments for category_to_article"""
    take: int
    skip: int
    order_by: Union['commentOrderByInput', List['commentOrderByInput']]
    where: 'commentWhereInput'
    cursor: 'commentWhereUniqueInput'
    distinct: List['commentScalarFieldKeys']
    
    

class likeIncludeFromcategory_to_article(TypedDict, total=False):
    """Relational arguments for category_to_article"""
    article: Union[bool, 'articleArgsFromcategory_to_articleRecursive1']
    user: Union[bool, 'userArgsFromcategory_to_articleRecursive1']


class likeIncludeFromcategory_to_articleRecursive1(TypedDict, total=False):
    """Relational arguments for category_to_article"""
    article: Union[bool, 'articleArgsFromcategory_to_articleRecursive2']
    user: Union[bool, 'userArgsFromcategory_to_articleRecursive2']


class likeIncludeFromcategory_to_articleRecursive2(TypedDict, total=False):
    """Relational arguments for category_to_article"""
    article: Union[bool, 'articleArgsFromcategory_to_articleRecursive3']
    user: Union[bool, 'userArgsFromcategory_to_articleRecursive3']


class likeIncludeFromcategory_to_articleRecursive3(TypedDict, total=False):
    """Relational arguments for category_to_article"""
    article: Union[bool, 'articleArgsFromcategory_to_articleRecursive4']
    user: Union[bool, 'userArgsFromcategory_to_articleRecursive4']


class likeIncludeFromcategory_to_articleRecursive4(TypedDict, total=False):
    """Relational arguments for category_to_article"""

    

class likeArgsFromcategory_to_article(TypedDict, total=False):
    """Arguments for category_to_article"""
    include: 'likeIncludeFromlikeRecursive1'


class likeArgsFromcategory_to_articleRecursive1(TypedDict, total=False):
    """Arguments for category_to_article"""
    include: 'likeIncludeFromlikeRecursive2'


class likeArgsFromcategory_to_articleRecursive2(TypedDict, total=False):
    """Arguments for category_to_article"""
    include: 'likeIncludeFromlikeRecursive3'


class likeArgsFromcategory_to_articleRecursive3(TypedDict, total=False):
    """Arguments for category_to_article"""
    include: 'likeIncludeFromlikeRecursive4'


class likeArgsFromcategory_to_articleRecursive4(TypedDict, total=False):
    """Arguments for category_to_article"""
    
    

class FindManylikeArgsFromcategory_to_article(TypedDict, total=False):
    """Arguments for category_to_article"""
    take: int
    skip: int
    order_by: Union['likeOrderByInput', List['likeOrderByInput']]
    where: 'likeWhereInput'
    cursor: 'likeWhereUniqueInput'
    distinct: List['likeScalarFieldKeys']
    include: 'likeIncludeFromlikeRecursive1'


class FindManylikeArgsFromcategory_to_articleRecursive1(TypedDict, total=False):
    """Arguments for category_to_article"""
    take: int
    skip: int
    order_by: Union['likeOrderByInput', List['likeOrderByInput']]
    where: 'likeWhereInput'
    cursor: 'likeWhereUniqueInput'
    distinct: List['likeScalarFieldKeys']
    include: 'likeIncludeFromlikeRecursive2'


class FindManylikeArgsFromcategory_to_articleRecursive2(TypedDict, total=False):
    """Arguments for category_to_article"""
    take: int
    skip: int
    order_by: Union['likeOrderByInput', List['likeOrderByInput']]
    where: 'likeWhereInput'
    cursor: 'likeWhereUniqueInput'
    distinct: List['likeScalarFieldKeys']
    include: 'likeIncludeFromlikeRecursive3'


class FindManylikeArgsFromcategory_to_articleRecursive3(TypedDict, total=False):
    """Arguments for category_to_article"""
    take: int
    skip: int
    order_by: Union['likeOrderByInput', List['likeOrderByInput']]
    where: 'likeWhereInput'
    cursor: 'likeWhereUniqueInput'
    distinct: List['likeScalarFieldKeys']
    include: 'likeIncludeFromlikeRecursive4'


class FindManylikeArgsFromcategory_to_articleRecursive4(TypedDict, total=False):
    """Arguments for category_to_article"""
    take: int
    skip: int
    order_by: Union['likeOrderByInput', List['likeOrderByInput']]
    where: 'likeWhereInput'
    cursor: 'likeWhereUniqueInput'
    distinct: List['likeScalarFieldKeys']
    
    

class fileIncludeFromcategory_to_article(TypedDict, total=False):
    """Relational arguments for category_to_article"""
    article: Union[bool, 'articleArgsFromcategory_to_articleRecursive1']


class fileIncludeFromcategory_to_articleRecursive1(TypedDict, total=False):
    """Relational arguments for category_to_article"""
    article: Union[bool, 'articleArgsFromcategory_to_articleRecursive2']


class fileIncludeFromcategory_to_articleRecursive2(TypedDict, total=False):
    """Relational arguments for category_to_article"""
    article: Union[bool, 'articleArgsFromcategory_to_articleRecursive3']


class fileIncludeFromcategory_to_articleRecursive3(TypedDict, total=False):
    """Relational arguments for category_to_article"""
    article: Union[bool, 'articleArgsFromcategory_to_articleRecursive4']


class fileIncludeFromcategory_to_articleRecursive4(TypedDict, total=False):
    """Relational arguments for category_to_article"""

    

class fileArgsFromcategory_to_article(TypedDict, total=False):
    """Arguments for category_to_article"""
    include: 'fileIncludeFromfileRecursive1'


class fileArgsFromcategory_to_articleRecursive1(TypedDict, total=False):
    """Arguments for category_to_article"""
    include: 'fileIncludeFromfileRecursive2'


class fileArgsFromcategory_to_articleRecursive2(TypedDict, total=False):
    """Arguments for category_to_article"""
    include: 'fileIncludeFromfileRecursive3'


class fileArgsFromcategory_to_articleRecursive3(TypedDict, total=False):
    """Arguments for category_to_article"""
    include: 'fileIncludeFromfileRecursive4'


class fileArgsFromcategory_to_articleRecursive4(TypedDict, total=False):
    """Arguments for category_to_article"""
    
    

class FindManyfileArgsFromcategory_to_article(TypedDict, total=False):
    """Arguments for category_to_article"""
    take: int
    skip: int
    order_by: Union['fileOrderByInput', List['fileOrderByInput']]
    where: 'fileWhereInput'
    cursor: 'fileWhereUniqueInput'
    distinct: List['fileScalarFieldKeys']
    include: 'fileIncludeFromfileRecursive1'


class FindManyfileArgsFromcategory_to_articleRecursive1(TypedDict, total=False):
    """Arguments for category_to_article"""
    take: int
    skip: int
    order_by: Union['fileOrderByInput', List['fileOrderByInput']]
    where: 'fileWhereInput'
    cursor: 'fileWhereUniqueInput'
    distinct: List['fileScalarFieldKeys']
    include: 'fileIncludeFromfileRecursive2'


class FindManyfileArgsFromcategory_to_articleRecursive2(TypedDict, total=False):
    """Arguments for category_to_article"""
    take: int
    skip: int
    order_by: Union['fileOrderByInput', List['fileOrderByInput']]
    where: 'fileWhereInput'
    cursor: 'fileWhereUniqueInput'
    distinct: List['fileScalarFieldKeys']
    include: 'fileIncludeFromfileRecursive3'


class FindManyfileArgsFromcategory_to_articleRecursive3(TypedDict, total=False):
    """Arguments for category_to_article"""
    take: int
    skip: int
    order_by: Union['fileOrderByInput', List['fileOrderByInput']]
    where: 'fileWhereInput'
    cursor: 'fileWhereUniqueInput'
    distinct: List['fileScalarFieldKeys']
    include: 'fileIncludeFromfileRecursive4'


class FindManyfileArgsFromcategory_to_articleRecursive4(TypedDict, total=False):
    """Arguments for category_to_article"""
    take: int
    skip: int
    order_by: Union['fileOrderByInput', List['fileOrderByInput']]
    where: 'fileWhereInput'
    cursor: 'fileWhereUniqueInput'
    distinct: List['fileScalarFieldKeys']
    


FindManycategory_to_articleArgs = FindManycategory_to_articleArgsFromcategory_to_article
FindFirstcategory_to_articleArgs = FindManycategory_to_articleArgsFromcategory_to_article


    

class category_to_articleWhereInput(TypedDict, total=False):
    """category_to_article arguments for searching"""
    article_id: Union[_int, 'types.IntFilter']
    category_id: Union[_int, 'types.IntFilter']
    article: 'articleRelationFilter'
    category: 'categoryRelationFilter'

    # should be noted that AND and NOT should be Union['category_to_articleWhereInputRecursive1', List['category_to_articleWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['category_to_articleWhereInputRecursive1']
    OR: List['category_to_articleWhereInputRecursive1']
    NOT: List['category_to_articleWhereInputRecursive1']


class category_to_articleWhereInputRecursive1(TypedDict, total=False):
    """category_to_article arguments for searching"""
    article_id: Union[_int, 'types.IntFilter']
    category_id: Union[_int, 'types.IntFilter']
    article: 'articleRelationFilter'
    category: 'categoryRelationFilter'

    # should be noted that AND and NOT should be Union['category_to_articleWhereInputRecursive2', List['category_to_articleWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['category_to_articleWhereInputRecursive2']
    OR: List['category_to_articleWhereInputRecursive2']
    NOT: List['category_to_articleWhereInputRecursive2']


class category_to_articleWhereInputRecursive2(TypedDict, total=False):
    """category_to_article arguments for searching"""
    article_id: Union[_int, 'types.IntFilter']
    category_id: Union[_int, 'types.IntFilter']
    article: 'articleRelationFilter'
    category: 'categoryRelationFilter'

    # should be noted that AND and NOT should be Union['category_to_articleWhereInputRecursive3', List['category_to_articleWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['category_to_articleWhereInputRecursive3']
    OR: List['category_to_articleWhereInputRecursive3']
    NOT: List['category_to_articleWhereInputRecursive3']


class category_to_articleWhereInputRecursive3(TypedDict, total=False):
    """category_to_article arguments for searching"""
    article_id: Union[_int, 'types.IntFilter']
    category_id: Union[_int, 'types.IntFilter']
    article: 'articleRelationFilter'
    category: 'categoryRelationFilter'

    # should be noted that AND and NOT should be Union['category_to_articleWhereInputRecursive4', List['category_to_articleWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['category_to_articleWhereInputRecursive4']
    OR: List['category_to_articleWhereInputRecursive4']
    NOT: List['category_to_articleWhereInputRecursive4']


class category_to_articleWhereInputRecursive4(TypedDict, total=False):
    """category_to_article arguments for searching"""
    article_id: Union[_int, 'types.IntFilter']
    category_id: Union[_int, 'types.IntFilter']
    article: 'articleRelationFilter'
    category: 'categoryRelationFilter'



# aggregate category_to_article types


    

class category_to_articleScalarWhereWithAggregatesInput(TypedDict, total=False):
    """category_to_article arguments for searching"""
    article_id: Union[_int, 'types.IntWithAggregatesFilter']
    category_id: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['category_to_articleScalarWhereWithAggregatesInputRecursive1']
    OR: List['category_to_articleScalarWhereWithAggregatesInputRecursive1']
    NOT: List['category_to_articleScalarWhereWithAggregatesInputRecursive1']


class category_to_articleScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """category_to_article arguments for searching"""
    article_id: Union[_int, 'types.IntWithAggregatesFilter']
    category_id: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['category_to_articleScalarWhereWithAggregatesInputRecursive2']
    OR: List['category_to_articleScalarWhereWithAggregatesInputRecursive2']
    NOT: List['category_to_articleScalarWhereWithAggregatesInputRecursive2']


class category_to_articleScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """category_to_article arguments for searching"""
    article_id: Union[_int, 'types.IntWithAggregatesFilter']
    category_id: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['category_to_articleScalarWhereWithAggregatesInputRecursive3']
    OR: List['category_to_articleScalarWhereWithAggregatesInputRecursive3']
    NOT: List['category_to_articleScalarWhereWithAggregatesInputRecursive3']


class category_to_articleScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """category_to_article arguments for searching"""
    article_id: Union[_int, 'types.IntWithAggregatesFilter']
    category_id: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['category_to_articleScalarWhereWithAggregatesInputRecursive4']
    OR: List['category_to_articleScalarWhereWithAggregatesInputRecursive4']
    NOT: List['category_to_articleScalarWhereWithAggregatesInputRecursive4']


class category_to_articleScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """category_to_article arguments for searching"""
    article_id: Union[_int, 'types.IntWithAggregatesFilter']
    category_id: Union[_int, 'types.IntWithAggregatesFilter']



class category_to_articleGroupByOutput(TypedDict, total=False):
    article_id: _int
    category_id: _int
    _sum: 'category_to_articleSumAggregateOutput'
    _avg: 'category_to_articleAvgAggregateOutput'
    _min: 'category_to_articleMinAggregateOutput'
    _max: 'category_to_articleMaxAggregateOutput'
    _count: 'category_to_articleCountAggregateOutput'


class category_to_articleAvgAggregateOutput(TypedDict, total=False):
    """category_to_article output for aggregating averages"""
    article_id: float
    category_id: float


class category_to_articleSumAggregateOutput(TypedDict, total=False):
    """category_to_article output for aggregating sums"""
    article_id: _int
    category_id: _int


class category_to_articleScalarAggregateOutput(TypedDict, total=False):
    """category_to_article output including scalar fields"""
    article_id: _int
    category_id: _int


category_to_articleMinAggregateOutput = category_to_articleScalarAggregateOutput
category_to_articleMaxAggregateOutput = category_to_articleScalarAggregateOutput


class category_to_articleMaxAggregateInput(TypedDict, total=False):
    """category_to_article input for aggregating by max"""
    article_id: bool
    category_id: bool


class category_to_articleMinAggregateInput(TypedDict, total=False):
    """category_to_article input for aggregating by min"""
    article_id: bool
    category_id: bool


class category_to_articleNumberAggregateInput(TypedDict, total=False):
    """category_to_article input for aggregating numbers"""
    article_id: bool
    category_id: bool


category_to_articleAvgAggregateInput = category_to_articleNumberAggregateInput
category_to_articleSumAggregateInput = category_to_articleNumberAggregateInput


category_to_articleCountAggregateInput = TypedDict(
    'category_to_articleCountAggregateInput',
    {
        'article_id': bool,
        'category_id': bool,
        '_all': bool,
    },
    total=False,
)

category_to_articleCountAggregateOutput = TypedDict(
    'category_to_articleCountAggregateOutput',
    {
        'article_id': int,
        'category_id': int,
        '_all': int,
    },
    total=False,
)


category_to_articleKeys = Literal[
    'article_id',
    'category_id',
    'article',
    'category',
]
category_to_articleScalarFieldKeys = Literal[
    'article_id',
    'category_id',
]
category_to_articleScalarFieldKeysT = TypeVar('category_to_articleScalarFieldKeysT', bound=category_to_articleScalarFieldKeys)

category_to_articleRelationalFieldKeys = Literal[
        'article',
        'category',
    ]

# comment types

class commentOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the comment create method"""
    id: _int
    created_at: datetime.datetime
    updated_at: datetime.datetime
    article_id: _int
    user_id: _int
    article: 'articleCreateNestedWithoutRelationsInput'
    user: 'userCreateNestedWithoutRelationsInput'


class commentCreateInput(commentOptionalCreateInput):
    """Required arguments to the comment create method"""
    content: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class commentOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the comment create method, without relations"""
    id: _int
    created_at: datetime.datetime
    updated_at: datetime.datetime
    article_id: _int
    user_id: _int


class commentCreateWithoutRelationsInput(commentOptionalCreateWithoutRelationsInput):
    """Required arguments to the comment create method, without relations"""
    content: _str

class commentConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'commentCreateWithoutRelationsInput'
    where: 'commentWhereUniqueInput'

class commentCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'commentCreateWithoutRelationsInput'
    connect: 'commentWhereUniqueInput'
    connect_or_create: 'commentConnectOrCreateWithoutRelationsInput'


class commentCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['commentCreateWithoutRelationsInput', List['commentCreateWithoutRelationsInput']]
    connect: Union['commentWhereUniqueInput', List['commentWhereUniqueInput']]
    connect_or_create: Union['commentConnectOrCreateWithoutRelationsInput', List['commentConnectOrCreateWithoutRelationsInput']]

_commentWhereUnique_id_Input = TypedDict(
    '_commentWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

commentWhereUniqueInput = _commentWhereUnique_id_Input


class commentUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    content: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    article: 'articleUpdateOneWithoutRelationsInput'
    user: 'userUpdateOneWithoutRelationsInput'


class commentUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    content: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime


class commentUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['commentCreateWithoutRelationsInput']
    connect: List['commentWhereUniqueInput']
    connect_or_create: List['commentConnectOrCreateWithoutRelationsInput']
    set: List['commentWhereUniqueInput']
    disconnect: List['commentWhereUniqueInput']
    delete: List['commentWhereUniqueInput']

    # TODO
    # update: List['commentUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['commentUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['commentScalarWhereInput']
    # upsert: List['commentUpserteWithWhereUniqueWithoutRelationsInput']


class commentUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'commentCreateWithoutRelationsInput'
    connect: 'commentWhereUniqueInput'
    connect_or_create: 'commentConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'commentUpdateInput'
    # upsert: 'commentUpsertWithoutRelationsInput'


class commentUpsertInput(TypedDict):
    create: 'commentCreateInput'
    update: 'commentUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_comment_id_OrderByInput = TypedDict(
    '_comment_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_comment_content_OrderByInput = TypedDict(
    '_comment_content_OrderByInput',
    {
        'content': 'SortOrder',
    },
    total=True
)

_comment_created_at_OrderByInput = TypedDict(
    '_comment_created_at_OrderByInput',
    {
        'created_at': 'SortOrder',
    },
    total=True
)

_comment_updated_at_OrderByInput = TypedDict(
    '_comment_updated_at_OrderByInput',
    {
        'updated_at': 'SortOrder',
    },
    total=True
)

_comment_article_id_OrderByInput = TypedDict(
    '_comment_article_id_OrderByInput',
    {
        'article_id': 'SortOrder',
    },
    total=True
)

_comment_user_id_OrderByInput = TypedDict(
    '_comment_user_id_OrderByInput',
    {
        'user_id': 'SortOrder',
    },
    total=True
)

_comment_RelevanceInner = TypedDict(
    '_comment_RelevanceInner',
    {
        'fields': 'List[commentScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_comment_RelevanceOrderByInput = TypedDict(
    '_comment_RelevanceOrderByInput',
    {
        '_relevance': '_comment_RelevanceInner',
    },
    total=True
)

commentOrderByInput = Union[
    '_comment_id_OrderByInput',
    '_comment_content_OrderByInput',
    '_comment_created_at_OrderByInput',
    '_comment_updated_at_OrderByInput',
    '_comment_article_id_OrderByInput',
    '_comment_user_id_OrderByInput',
    '_comment_RelevanceOrderByInput',
]



# recursive comment types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

commentRelationFilter = TypedDict(
    'commentRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class commentListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class commentInclude(TypedDict, total=False):
    """comment relational arguments"""
    article: Union[bool, 'articleArgsFromcomment']
    user: Union[bool, 'userArgsFromcomment']


    

class userIncludeFromcomment(TypedDict, total=False):
    """Relational arguments for comment"""
    articles: Union[bool, 'FindManyarticleArgsFromcommentRecursive1']
    comments: Union[bool, 'FindManycommentArgsFromcommentRecursive1']
    likes: Union[bool, 'FindManylikeArgsFromcommentRecursive1']


class userIncludeFromcommentRecursive1(TypedDict, total=False):
    """Relational arguments for comment"""
    articles: Union[bool, 'FindManyarticleArgsFromcommentRecursive2']
    comments: Union[bool, 'FindManycommentArgsFromcommentRecursive2']
    likes: Union[bool, 'FindManylikeArgsFromcommentRecursive2']


class userIncludeFromcommentRecursive2(TypedDict, total=False):
    """Relational arguments for comment"""
    articles: Union[bool, 'FindManyarticleArgsFromcommentRecursive3']
    comments: Union[bool, 'FindManycommentArgsFromcommentRecursive3']
    likes: Union[bool, 'FindManylikeArgsFromcommentRecursive3']


class userIncludeFromcommentRecursive3(TypedDict, total=False):
    """Relational arguments for comment"""
    articles: Union[bool, 'FindManyarticleArgsFromcommentRecursive4']
    comments: Union[bool, 'FindManycommentArgsFromcommentRecursive4']
    likes: Union[bool, 'FindManylikeArgsFromcommentRecursive4']


class userIncludeFromcommentRecursive4(TypedDict, total=False):
    """Relational arguments for comment"""

    

class userArgsFromcomment(TypedDict, total=False):
    """Arguments for comment"""
    include: 'userIncludeFromuserRecursive1'


class userArgsFromcommentRecursive1(TypedDict, total=False):
    """Arguments for comment"""
    include: 'userIncludeFromuserRecursive2'


class userArgsFromcommentRecursive2(TypedDict, total=False):
    """Arguments for comment"""
    include: 'userIncludeFromuserRecursive3'


class userArgsFromcommentRecursive3(TypedDict, total=False):
    """Arguments for comment"""
    include: 'userIncludeFromuserRecursive4'


class userArgsFromcommentRecursive4(TypedDict, total=False):
    """Arguments for comment"""
    
    

class FindManyuserArgsFromcomment(TypedDict, total=False):
    """Arguments for comment"""
    take: int
    skip: int
    order_by: Union['userOrderByInput', List['userOrderByInput']]
    where: 'userWhereInput'
    cursor: 'userWhereUniqueInput'
    distinct: List['userScalarFieldKeys']
    include: 'userIncludeFromuserRecursive1'


class FindManyuserArgsFromcommentRecursive1(TypedDict, total=False):
    """Arguments for comment"""
    take: int
    skip: int
    order_by: Union['userOrderByInput', List['userOrderByInput']]
    where: 'userWhereInput'
    cursor: 'userWhereUniqueInput'
    distinct: List['userScalarFieldKeys']
    include: 'userIncludeFromuserRecursive2'


class FindManyuserArgsFromcommentRecursive2(TypedDict, total=False):
    """Arguments for comment"""
    take: int
    skip: int
    order_by: Union['userOrderByInput', List['userOrderByInput']]
    where: 'userWhereInput'
    cursor: 'userWhereUniqueInput'
    distinct: List['userScalarFieldKeys']
    include: 'userIncludeFromuserRecursive3'


class FindManyuserArgsFromcommentRecursive3(TypedDict, total=False):
    """Arguments for comment"""
    take: int
    skip: int
    order_by: Union['userOrderByInput', List['userOrderByInput']]
    where: 'userWhereInput'
    cursor: 'userWhereUniqueInput'
    distinct: List['userScalarFieldKeys']
    include: 'userIncludeFromuserRecursive4'


class FindManyuserArgsFromcommentRecursive4(TypedDict, total=False):
    """Arguments for comment"""
    take: int
    skip: int
    order_by: Union['userOrderByInput', List['userOrderByInput']]
    where: 'userWhereInput'
    cursor: 'userWhereUniqueInput'
    distinct: List['userScalarFieldKeys']
    
    

class articleIncludeFromcomment(TypedDict, total=False):
    """Relational arguments for comment"""
    user: Union[bool, 'userArgsFromcommentRecursive1']
    comments: Union[bool, 'FindManycommentArgsFromcommentRecursive1']
    likes: Union[bool, 'FindManylikeArgsFromcommentRecursive1']
    categories: Union[bool, 'FindManycategory_to_articleArgsFromcommentRecursive1']
    files: Union[bool, 'FindManyfileArgsFromcommentRecursive1']


class articleIncludeFromcommentRecursive1(TypedDict, total=False):
    """Relational arguments for comment"""
    user: Union[bool, 'userArgsFromcommentRecursive2']
    comments: Union[bool, 'FindManycommentArgsFromcommentRecursive2']
    likes: Union[bool, 'FindManylikeArgsFromcommentRecursive2']
    categories: Union[bool, 'FindManycategory_to_articleArgsFromcommentRecursive2']
    files: Union[bool, 'FindManyfileArgsFromcommentRecursive2']


class articleIncludeFromcommentRecursive2(TypedDict, total=False):
    """Relational arguments for comment"""
    user: Union[bool, 'userArgsFromcommentRecursive3']
    comments: Union[bool, 'FindManycommentArgsFromcommentRecursive3']
    likes: Union[bool, 'FindManylikeArgsFromcommentRecursive3']
    categories: Union[bool, 'FindManycategory_to_articleArgsFromcommentRecursive3']
    files: Union[bool, 'FindManyfileArgsFromcommentRecursive3']


class articleIncludeFromcommentRecursive3(TypedDict, total=False):
    """Relational arguments for comment"""
    user: Union[bool, 'userArgsFromcommentRecursive4']
    comments: Union[bool, 'FindManycommentArgsFromcommentRecursive4']
    likes: Union[bool, 'FindManylikeArgsFromcommentRecursive4']
    categories: Union[bool, 'FindManycategory_to_articleArgsFromcommentRecursive4']
    files: Union[bool, 'FindManyfileArgsFromcommentRecursive4']


class articleIncludeFromcommentRecursive4(TypedDict, total=False):
    """Relational arguments for comment"""

    

class articleArgsFromcomment(TypedDict, total=False):
    """Arguments for comment"""
    include: 'articleIncludeFromarticleRecursive1'


class articleArgsFromcommentRecursive1(TypedDict, total=False):
    """Arguments for comment"""
    include: 'articleIncludeFromarticleRecursive2'


class articleArgsFromcommentRecursive2(TypedDict, total=False):
    """Arguments for comment"""
    include: 'articleIncludeFromarticleRecursive3'


class articleArgsFromcommentRecursive3(TypedDict, total=False):
    """Arguments for comment"""
    include: 'articleIncludeFromarticleRecursive4'


class articleArgsFromcommentRecursive4(TypedDict, total=False):
    """Arguments for comment"""
    
    

class FindManyarticleArgsFromcomment(TypedDict, total=False):
    """Arguments for comment"""
    take: int
    skip: int
    order_by: Union['articleOrderByInput', List['articleOrderByInput']]
    where: 'articleWhereInput'
    cursor: 'articleWhereUniqueInput'
    distinct: List['articleScalarFieldKeys']
    include: 'articleIncludeFromarticleRecursive1'


class FindManyarticleArgsFromcommentRecursive1(TypedDict, total=False):
    """Arguments for comment"""
    take: int
    skip: int
    order_by: Union['articleOrderByInput', List['articleOrderByInput']]
    where: 'articleWhereInput'
    cursor: 'articleWhereUniqueInput'
    distinct: List['articleScalarFieldKeys']
    include: 'articleIncludeFromarticleRecursive2'


class FindManyarticleArgsFromcommentRecursive2(TypedDict, total=False):
    """Arguments for comment"""
    take: int
    skip: int
    order_by: Union['articleOrderByInput', List['articleOrderByInput']]
    where: 'articleWhereInput'
    cursor: 'articleWhereUniqueInput'
    distinct: List['articleScalarFieldKeys']
    include: 'articleIncludeFromarticleRecursive3'


class FindManyarticleArgsFromcommentRecursive3(TypedDict, total=False):
    """Arguments for comment"""
    take: int
    skip: int
    order_by: Union['articleOrderByInput', List['articleOrderByInput']]
    where: 'articleWhereInput'
    cursor: 'articleWhereUniqueInput'
    distinct: List['articleScalarFieldKeys']
    include: 'articleIncludeFromarticleRecursive4'


class FindManyarticleArgsFromcommentRecursive4(TypedDict, total=False):
    """Arguments for comment"""
    take: int
    skip: int
    order_by: Union['articleOrderByInput', List['articleOrderByInput']]
    where: 'articleWhereInput'
    cursor: 'articleWhereUniqueInput'
    distinct: List['articleScalarFieldKeys']
    
    

class categoryIncludeFromcomment(TypedDict, total=False):
    """Relational arguments for comment"""
    articles: Union[bool, 'FindManycategory_to_articleArgsFromcommentRecursive1']


class categoryIncludeFromcommentRecursive1(TypedDict, total=False):
    """Relational arguments for comment"""
    articles: Union[bool, 'FindManycategory_to_articleArgsFromcommentRecursive2']


class categoryIncludeFromcommentRecursive2(TypedDict, total=False):
    """Relational arguments for comment"""
    articles: Union[bool, 'FindManycategory_to_articleArgsFromcommentRecursive3']


class categoryIncludeFromcommentRecursive3(TypedDict, total=False):
    """Relational arguments for comment"""
    articles: Union[bool, 'FindManycategory_to_articleArgsFromcommentRecursive4']


class categoryIncludeFromcommentRecursive4(TypedDict, total=False):
    """Relational arguments for comment"""

    

class categoryArgsFromcomment(TypedDict, total=False):
    """Arguments for comment"""
    include: 'categoryIncludeFromcategoryRecursive1'


class categoryArgsFromcommentRecursive1(TypedDict, total=False):
    """Arguments for comment"""
    include: 'categoryIncludeFromcategoryRecursive2'


class categoryArgsFromcommentRecursive2(TypedDict, total=False):
    """Arguments for comment"""
    include: 'categoryIncludeFromcategoryRecursive3'


class categoryArgsFromcommentRecursive3(TypedDict, total=False):
    """Arguments for comment"""
    include: 'categoryIncludeFromcategoryRecursive4'


class categoryArgsFromcommentRecursive4(TypedDict, total=False):
    """Arguments for comment"""
    
    

class FindManycategoryArgsFromcomment(TypedDict, total=False):
    """Arguments for comment"""
    take: int
    skip: int
    order_by: Union['categoryOrderByInput', List['categoryOrderByInput']]
    where: 'categoryWhereInput'
    cursor: 'categoryWhereUniqueInput'
    distinct: List['categoryScalarFieldKeys']
    include: 'categoryIncludeFromcategoryRecursive1'


class FindManycategoryArgsFromcommentRecursive1(TypedDict, total=False):
    """Arguments for comment"""
    take: int
    skip: int
    order_by: Union['categoryOrderByInput', List['categoryOrderByInput']]
    where: 'categoryWhereInput'
    cursor: 'categoryWhereUniqueInput'
    distinct: List['categoryScalarFieldKeys']
    include: 'categoryIncludeFromcategoryRecursive2'


class FindManycategoryArgsFromcommentRecursive2(TypedDict, total=False):
    """Arguments for comment"""
    take: int
    skip: int
    order_by: Union['categoryOrderByInput', List['categoryOrderByInput']]
    where: 'categoryWhereInput'
    cursor: 'categoryWhereUniqueInput'
    distinct: List['categoryScalarFieldKeys']
    include: 'categoryIncludeFromcategoryRecursive3'


class FindManycategoryArgsFromcommentRecursive3(TypedDict, total=False):
    """Arguments for comment"""
    take: int
    skip: int
    order_by: Union['categoryOrderByInput', List['categoryOrderByInput']]
    where: 'categoryWhereInput'
    cursor: 'categoryWhereUniqueInput'
    distinct: List['categoryScalarFieldKeys']
    include: 'categoryIncludeFromcategoryRecursive4'


class FindManycategoryArgsFromcommentRecursive4(TypedDict, total=False):
    """Arguments for comment"""
    take: int
    skip: int
    order_by: Union['categoryOrderByInput', List['categoryOrderByInput']]
    where: 'categoryWhereInput'
    cursor: 'categoryWhereUniqueInput'
    distinct: List['categoryScalarFieldKeys']
    
    

class category_to_articleIncludeFromcomment(TypedDict, total=False):
    """Relational arguments for comment"""
    article: Union[bool, 'articleArgsFromcommentRecursive1']
    category: Union[bool, 'categoryArgsFromcommentRecursive1']


class category_to_articleIncludeFromcommentRecursive1(TypedDict, total=False):
    """Relational arguments for comment"""
    article: Union[bool, 'articleArgsFromcommentRecursive2']
    category: Union[bool, 'categoryArgsFromcommentRecursive2']


class category_to_articleIncludeFromcommentRecursive2(TypedDict, total=False):
    """Relational arguments for comment"""
    article: Union[bool, 'articleArgsFromcommentRecursive3']
    category: Union[bool, 'categoryArgsFromcommentRecursive3']


class category_to_articleIncludeFromcommentRecursive3(TypedDict, total=False):
    """Relational arguments for comment"""
    article: Union[bool, 'articleArgsFromcommentRecursive4']
    category: Union[bool, 'categoryArgsFromcommentRecursive4']


class category_to_articleIncludeFromcommentRecursive4(TypedDict, total=False):
    """Relational arguments for comment"""

    

class category_to_articleArgsFromcomment(TypedDict, total=False):
    """Arguments for comment"""
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive1'


class category_to_articleArgsFromcommentRecursive1(TypedDict, total=False):
    """Arguments for comment"""
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive2'


class category_to_articleArgsFromcommentRecursive2(TypedDict, total=False):
    """Arguments for comment"""
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive3'


class category_to_articleArgsFromcommentRecursive3(TypedDict, total=False):
    """Arguments for comment"""
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive4'


class category_to_articleArgsFromcommentRecursive4(TypedDict, total=False):
    """Arguments for comment"""
    
    

class FindManycategory_to_articleArgsFromcomment(TypedDict, total=False):
    """Arguments for comment"""
    take: int
    skip: int
    order_by: Union['category_to_articleOrderByInput', List['category_to_articleOrderByInput']]
    where: 'category_to_articleWhereInput'
    cursor: 'category_to_articleWhereUniqueInput'
    distinct: List['category_to_articleScalarFieldKeys']
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive1'


class FindManycategory_to_articleArgsFromcommentRecursive1(TypedDict, total=False):
    """Arguments for comment"""
    take: int
    skip: int
    order_by: Union['category_to_articleOrderByInput', List['category_to_articleOrderByInput']]
    where: 'category_to_articleWhereInput'
    cursor: 'category_to_articleWhereUniqueInput'
    distinct: List['category_to_articleScalarFieldKeys']
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive2'


class FindManycategory_to_articleArgsFromcommentRecursive2(TypedDict, total=False):
    """Arguments for comment"""
    take: int
    skip: int
    order_by: Union['category_to_articleOrderByInput', List['category_to_articleOrderByInput']]
    where: 'category_to_articleWhereInput'
    cursor: 'category_to_articleWhereUniqueInput'
    distinct: List['category_to_articleScalarFieldKeys']
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive3'


class FindManycategory_to_articleArgsFromcommentRecursive3(TypedDict, total=False):
    """Arguments for comment"""
    take: int
    skip: int
    order_by: Union['category_to_articleOrderByInput', List['category_to_articleOrderByInput']]
    where: 'category_to_articleWhereInput'
    cursor: 'category_to_articleWhereUniqueInput'
    distinct: List['category_to_articleScalarFieldKeys']
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive4'


class FindManycategory_to_articleArgsFromcommentRecursive4(TypedDict, total=False):
    """Arguments for comment"""
    take: int
    skip: int
    order_by: Union['category_to_articleOrderByInput', List['category_to_articleOrderByInput']]
    where: 'category_to_articleWhereInput'
    cursor: 'category_to_articleWhereUniqueInput'
    distinct: List['category_to_articleScalarFieldKeys']
    
    

class commentIncludeFromcomment(TypedDict, total=False):
    """Relational arguments for comment"""
    article: Union[bool, 'articleArgsFromcommentRecursive1']
    user: Union[bool, 'userArgsFromcommentRecursive1']


class commentIncludeFromcommentRecursive1(TypedDict, total=False):
    """Relational arguments for comment"""
    article: Union[bool, 'articleArgsFromcommentRecursive2']
    user: Union[bool, 'userArgsFromcommentRecursive2']


class commentIncludeFromcommentRecursive2(TypedDict, total=False):
    """Relational arguments for comment"""
    article: Union[bool, 'articleArgsFromcommentRecursive3']
    user: Union[bool, 'userArgsFromcommentRecursive3']


class commentIncludeFromcommentRecursive3(TypedDict, total=False):
    """Relational arguments for comment"""
    article: Union[bool, 'articleArgsFromcommentRecursive4']
    user: Union[bool, 'userArgsFromcommentRecursive4']


class commentIncludeFromcommentRecursive4(TypedDict, total=False):
    """Relational arguments for comment"""

    

class commentArgsFromcomment(TypedDict, total=False):
    """Arguments for comment"""
    include: 'commentIncludeFromcommentRecursive1'


class commentArgsFromcommentRecursive1(TypedDict, total=False):
    """Arguments for comment"""
    include: 'commentIncludeFromcommentRecursive2'


class commentArgsFromcommentRecursive2(TypedDict, total=False):
    """Arguments for comment"""
    include: 'commentIncludeFromcommentRecursive3'


class commentArgsFromcommentRecursive3(TypedDict, total=False):
    """Arguments for comment"""
    include: 'commentIncludeFromcommentRecursive4'


class commentArgsFromcommentRecursive4(TypedDict, total=False):
    """Arguments for comment"""
    
    

class FindManycommentArgsFromcomment(TypedDict, total=False):
    """Arguments for comment"""
    take: int
    skip: int
    order_by: Union['commentOrderByInput', List['commentOrderByInput']]
    where: 'commentWhereInput'
    cursor: 'commentWhereUniqueInput'
    distinct: List['commentScalarFieldKeys']
    include: 'commentIncludeFromcommentRecursive1'


class FindManycommentArgsFromcommentRecursive1(TypedDict, total=False):
    """Arguments for comment"""
    take: int
    skip: int
    order_by: Union['commentOrderByInput', List['commentOrderByInput']]
    where: 'commentWhereInput'
    cursor: 'commentWhereUniqueInput'
    distinct: List['commentScalarFieldKeys']
    include: 'commentIncludeFromcommentRecursive2'


class FindManycommentArgsFromcommentRecursive2(TypedDict, total=False):
    """Arguments for comment"""
    take: int
    skip: int
    order_by: Union['commentOrderByInput', List['commentOrderByInput']]
    where: 'commentWhereInput'
    cursor: 'commentWhereUniqueInput'
    distinct: List['commentScalarFieldKeys']
    include: 'commentIncludeFromcommentRecursive3'


class FindManycommentArgsFromcommentRecursive3(TypedDict, total=False):
    """Arguments for comment"""
    take: int
    skip: int
    order_by: Union['commentOrderByInput', List['commentOrderByInput']]
    where: 'commentWhereInput'
    cursor: 'commentWhereUniqueInput'
    distinct: List['commentScalarFieldKeys']
    include: 'commentIncludeFromcommentRecursive4'


class FindManycommentArgsFromcommentRecursive4(TypedDict, total=False):
    """Arguments for comment"""
    take: int
    skip: int
    order_by: Union['commentOrderByInput', List['commentOrderByInput']]
    where: 'commentWhereInput'
    cursor: 'commentWhereUniqueInput'
    distinct: List['commentScalarFieldKeys']
    
    

class likeIncludeFromcomment(TypedDict, total=False):
    """Relational arguments for comment"""
    article: Union[bool, 'articleArgsFromcommentRecursive1']
    user: Union[bool, 'userArgsFromcommentRecursive1']


class likeIncludeFromcommentRecursive1(TypedDict, total=False):
    """Relational arguments for comment"""
    article: Union[bool, 'articleArgsFromcommentRecursive2']
    user: Union[bool, 'userArgsFromcommentRecursive2']


class likeIncludeFromcommentRecursive2(TypedDict, total=False):
    """Relational arguments for comment"""
    article: Union[bool, 'articleArgsFromcommentRecursive3']
    user: Union[bool, 'userArgsFromcommentRecursive3']


class likeIncludeFromcommentRecursive3(TypedDict, total=False):
    """Relational arguments for comment"""
    article: Union[bool, 'articleArgsFromcommentRecursive4']
    user: Union[bool, 'userArgsFromcommentRecursive4']


class likeIncludeFromcommentRecursive4(TypedDict, total=False):
    """Relational arguments for comment"""

    

class likeArgsFromcomment(TypedDict, total=False):
    """Arguments for comment"""
    include: 'likeIncludeFromlikeRecursive1'


class likeArgsFromcommentRecursive1(TypedDict, total=False):
    """Arguments for comment"""
    include: 'likeIncludeFromlikeRecursive2'


class likeArgsFromcommentRecursive2(TypedDict, total=False):
    """Arguments for comment"""
    include: 'likeIncludeFromlikeRecursive3'


class likeArgsFromcommentRecursive3(TypedDict, total=False):
    """Arguments for comment"""
    include: 'likeIncludeFromlikeRecursive4'


class likeArgsFromcommentRecursive4(TypedDict, total=False):
    """Arguments for comment"""
    
    

class FindManylikeArgsFromcomment(TypedDict, total=False):
    """Arguments for comment"""
    take: int
    skip: int
    order_by: Union['likeOrderByInput', List['likeOrderByInput']]
    where: 'likeWhereInput'
    cursor: 'likeWhereUniqueInput'
    distinct: List['likeScalarFieldKeys']
    include: 'likeIncludeFromlikeRecursive1'


class FindManylikeArgsFromcommentRecursive1(TypedDict, total=False):
    """Arguments for comment"""
    take: int
    skip: int
    order_by: Union['likeOrderByInput', List['likeOrderByInput']]
    where: 'likeWhereInput'
    cursor: 'likeWhereUniqueInput'
    distinct: List['likeScalarFieldKeys']
    include: 'likeIncludeFromlikeRecursive2'


class FindManylikeArgsFromcommentRecursive2(TypedDict, total=False):
    """Arguments for comment"""
    take: int
    skip: int
    order_by: Union['likeOrderByInput', List['likeOrderByInput']]
    where: 'likeWhereInput'
    cursor: 'likeWhereUniqueInput'
    distinct: List['likeScalarFieldKeys']
    include: 'likeIncludeFromlikeRecursive3'


class FindManylikeArgsFromcommentRecursive3(TypedDict, total=False):
    """Arguments for comment"""
    take: int
    skip: int
    order_by: Union['likeOrderByInput', List['likeOrderByInput']]
    where: 'likeWhereInput'
    cursor: 'likeWhereUniqueInput'
    distinct: List['likeScalarFieldKeys']
    include: 'likeIncludeFromlikeRecursive4'


class FindManylikeArgsFromcommentRecursive4(TypedDict, total=False):
    """Arguments for comment"""
    take: int
    skip: int
    order_by: Union['likeOrderByInput', List['likeOrderByInput']]
    where: 'likeWhereInput'
    cursor: 'likeWhereUniqueInput'
    distinct: List['likeScalarFieldKeys']
    
    

class fileIncludeFromcomment(TypedDict, total=False):
    """Relational arguments for comment"""
    article: Union[bool, 'articleArgsFromcommentRecursive1']


class fileIncludeFromcommentRecursive1(TypedDict, total=False):
    """Relational arguments for comment"""
    article: Union[bool, 'articleArgsFromcommentRecursive2']


class fileIncludeFromcommentRecursive2(TypedDict, total=False):
    """Relational arguments for comment"""
    article: Union[bool, 'articleArgsFromcommentRecursive3']


class fileIncludeFromcommentRecursive3(TypedDict, total=False):
    """Relational arguments for comment"""
    article: Union[bool, 'articleArgsFromcommentRecursive4']


class fileIncludeFromcommentRecursive4(TypedDict, total=False):
    """Relational arguments for comment"""

    

class fileArgsFromcomment(TypedDict, total=False):
    """Arguments for comment"""
    include: 'fileIncludeFromfileRecursive1'


class fileArgsFromcommentRecursive1(TypedDict, total=False):
    """Arguments for comment"""
    include: 'fileIncludeFromfileRecursive2'


class fileArgsFromcommentRecursive2(TypedDict, total=False):
    """Arguments for comment"""
    include: 'fileIncludeFromfileRecursive3'


class fileArgsFromcommentRecursive3(TypedDict, total=False):
    """Arguments for comment"""
    include: 'fileIncludeFromfileRecursive4'


class fileArgsFromcommentRecursive4(TypedDict, total=False):
    """Arguments for comment"""
    
    

class FindManyfileArgsFromcomment(TypedDict, total=False):
    """Arguments for comment"""
    take: int
    skip: int
    order_by: Union['fileOrderByInput', List['fileOrderByInput']]
    where: 'fileWhereInput'
    cursor: 'fileWhereUniqueInput'
    distinct: List['fileScalarFieldKeys']
    include: 'fileIncludeFromfileRecursive1'


class FindManyfileArgsFromcommentRecursive1(TypedDict, total=False):
    """Arguments for comment"""
    take: int
    skip: int
    order_by: Union['fileOrderByInput', List['fileOrderByInput']]
    where: 'fileWhereInput'
    cursor: 'fileWhereUniqueInput'
    distinct: List['fileScalarFieldKeys']
    include: 'fileIncludeFromfileRecursive2'


class FindManyfileArgsFromcommentRecursive2(TypedDict, total=False):
    """Arguments for comment"""
    take: int
    skip: int
    order_by: Union['fileOrderByInput', List['fileOrderByInput']]
    where: 'fileWhereInput'
    cursor: 'fileWhereUniqueInput'
    distinct: List['fileScalarFieldKeys']
    include: 'fileIncludeFromfileRecursive3'


class FindManyfileArgsFromcommentRecursive3(TypedDict, total=False):
    """Arguments for comment"""
    take: int
    skip: int
    order_by: Union['fileOrderByInput', List['fileOrderByInput']]
    where: 'fileWhereInput'
    cursor: 'fileWhereUniqueInput'
    distinct: List['fileScalarFieldKeys']
    include: 'fileIncludeFromfileRecursive4'


class FindManyfileArgsFromcommentRecursive4(TypedDict, total=False):
    """Arguments for comment"""
    take: int
    skip: int
    order_by: Union['fileOrderByInput', List['fileOrderByInput']]
    where: 'fileWhereInput'
    cursor: 'fileWhereUniqueInput'
    distinct: List['fileScalarFieldKeys']
    


FindManycommentArgs = FindManycommentArgsFromcomment
FindFirstcommentArgs = FindManycommentArgsFromcomment


    

class commentWhereInput(TypedDict, total=False):
    """comment arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    content: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    article_id: Union[_int, 'types.IntFilter']
    user_id: Union[_int, 'types.IntFilter']
    article: 'articleRelationFilter'
    user: 'userRelationFilter'

    # should be noted that AND and NOT should be Union['commentWhereInputRecursive1', List['commentWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['commentWhereInputRecursive1']
    OR: List['commentWhereInputRecursive1']
    NOT: List['commentWhereInputRecursive1']


class commentWhereInputRecursive1(TypedDict, total=False):
    """comment arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    content: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    article_id: Union[_int, 'types.IntFilter']
    user_id: Union[_int, 'types.IntFilter']
    article: 'articleRelationFilter'
    user: 'userRelationFilter'

    # should be noted that AND and NOT should be Union['commentWhereInputRecursive2', List['commentWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['commentWhereInputRecursive2']
    OR: List['commentWhereInputRecursive2']
    NOT: List['commentWhereInputRecursive2']


class commentWhereInputRecursive2(TypedDict, total=False):
    """comment arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    content: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    article_id: Union[_int, 'types.IntFilter']
    user_id: Union[_int, 'types.IntFilter']
    article: 'articleRelationFilter'
    user: 'userRelationFilter'

    # should be noted that AND and NOT should be Union['commentWhereInputRecursive3', List['commentWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['commentWhereInputRecursive3']
    OR: List['commentWhereInputRecursive3']
    NOT: List['commentWhereInputRecursive3']


class commentWhereInputRecursive3(TypedDict, total=False):
    """comment arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    content: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    article_id: Union[_int, 'types.IntFilter']
    user_id: Union[_int, 'types.IntFilter']
    article: 'articleRelationFilter'
    user: 'userRelationFilter'

    # should be noted that AND and NOT should be Union['commentWhereInputRecursive4', List['commentWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['commentWhereInputRecursive4']
    OR: List['commentWhereInputRecursive4']
    NOT: List['commentWhereInputRecursive4']


class commentWhereInputRecursive4(TypedDict, total=False):
    """comment arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    content: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    article_id: Union[_int, 'types.IntFilter']
    user_id: Union[_int, 'types.IntFilter']
    article: 'articleRelationFilter'
    user: 'userRelationFilter'



# aggregate comment types


    

class commentScalarWhereWithAggregatesInput(TypedDict, total=False):
    """comment arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    content: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    article_id: Union[_int, 'types.IntWithAggregatesFilter']
    user_id: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['commentScalarWhereWithAggregatesInputRecursive1']
    OR: List['commentScalarWhereWithAggregatesInputRecursive1']
    NOT: List['commentScalarWhereWithAggregatesInputRecursive1']


class commentScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """comment arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    content: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    article_id: Union[_int, 'types.IntWithAggregatesFilter']
    user_id: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['commentScalarWhereWithAggregatesInputRecursive2']
    OR: List['commentScalarWhereWithAggregatesInputRecursive2']
    NOT: List['commentScalarWhereWithAggregatesInputRecursive2']


class commentScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """comment arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    content: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    article_id: Union[_int, 'types.IntWithAggregatesFilter']
    user_id: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['commentScalarWhereWithAggregatesInputRecursive3']
    OR: List['commentScalarWhereWithAggregatesInputRecursive3']
    NOT: List['commentScalarWhereWithAggregatesInputRecursive3']


class commentScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """comment arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    content: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    article_id: Union[_int, 'types.IntWithAggregatesFilter']
    user_id: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['commentScalarWhereWithAggregatesInputRecursive4']
    OR: List['commentScalarWhereWithAggregatesInputRecursive4']
    NOT: List['commentScalarWhereWithAggregatesInputRecursive4']


class commentScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """comment arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    content: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    article_id: Union[_int, 'types.IntWithAggregatesFilter']
    user_id: Union[_int, 'types.IntWithAggregatesFilter']



class commentGroupByOutput(TypedDict, total=False):
    id: _int
    content: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    article_id: _int
    user_id: _int
    _sum: 'commentSumAggregateOutput'
    _avg: 'commentAvgAggregateOutput'
    _min: 'commentMinAggregateOutput'
    _max: 'commentMaxAggregateOutput'
    _count: 'commentCountAggregateOutput'


class commentAvgAggregateOutput(TypedDict, total=False):
    """comment output for aggregating averages"""
    id: float
    article_id: float
    user_id: float


class commentSumAggregateOutput(TypedDict, total=False):
    """comment output for aggregating sums"""
    id: _int
    article_id: _int
    user_id: _int


class commentScalarAggregateOutput(TypedDict, total=False):
    """comment output including scalar fields"""
    id: _int
    content: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    article_id: _int
    user_id: _int


commentMinAggregateOutput = commentScalarAggregateOutput
commentMaxAggregateOutput = commentScalarAggregateOutput


class commentMaxAggregateInput(TypedDict, total=False):
    """comment input for aggregating by max"""
    id: bool
    content: bool
    created_at: bool
    updated_at: bool
    article_id: bool
    user_id: bool


class commentMinAggregateInput(TypedDict, total=False):
    """comment input for aggregating by min"""
    id: bool
    content: bool
    created_at: bool
    updated_at: bool
    article_id: bool
    user_id: bool


class commentNumberAggregateInput(TypedDict, total=False):
    """comment input for aggregating numbers"""
    id: bool
    article_id: bool
    user_id: bool


commentAvgAggregateInput = commentNumberAggregateInput
commentSumAggregateInput = commentNumberAggregateInput


commentCountAggregateInput = TypedDict(
    'commentCountAggregateInput',
    {
        'id': bool,
        'content': bool,
        'created_at': bool,
        'updated_at': bool,
        'article_id': bool,
        'user_id': bool,
        '_all': bool,
    },
    total=False,
)

commentCountAggregateOutput = TypedDict(
    'commentCountAggregateOutput',
    {
        'id': int,
        'content': int,
        'created_at': int,
        'updated_at': int,
        'article_id': int,
        'user_id': int,
        '_all': int,
    },
    total=False,
)


commentKeys = Literal[
    'id',
    'content',
    'created_at',
    'updated_at',
    'article_id',
    'user_id',
    'article',
    'user',
]
commentScalarFieldKeys = Literal[
    'id',
    'content',
    'created_at',
    'updated_at',
    'article_id',
    'user_id',
]
commentScalarFieldKeysT = TypeVar('commentScalarFieldKeysT', bound=commentScalarFieldKeys)

commentRelationalFieldKeys = Literal[
        'article',
        'user',
    ]

# like types

class likeOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the like create method"""
    created_at: datetime.datetime
    updated_at: datetime.datetime
    article_id: _int
    user_id: _int
    article: 'articleCreateNestedWithoutRelationsInput'
    user: 'userCreateNestedWithoutRelationsInput'


class likeCreateInput(likeOptionalCreateInput):
    """Required arguments to the like create method"""


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class likeOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the like create method, without relations"""
    created_at: datetime.datetime
    updated_at: datetime.datetime
    article_id: _int
    user_id: _int


class likeCreateWithoutRelationsInput(likeOptionalCreateWithoutRelationsInput):
    """Required arguments to the like create method, without relations"""

class likeConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'likeCreateWithoutRelationsInput'
    where: 'likeWhereUniqueInput'

class likeCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'likeCreateWithoutRelationsInput'
    connect: 'likeWhereUniqueInput'
    connect_or_create: 'likeConnectOrCreateWithoutRelationsInput'


class likeCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['likeCreateWithoutRelationsInput', List['likeCreateWithoutRelationsInput']]
    connect: Union['likeWhereUniqueInput', List['likeWhereUniqueInput']]
    connect_or_create: Union['likeConnectOrCreateWithoutRelationsInput', List['likeConnectOrCreateWithoutRelationsInput']]

_likeCompoundPrimaryKeyInner = TypedDict(
    '_likeCompoundPrimaryKeyInner',
    {
        'article_id': '_int',
        'user_id': '_int',
    },
    total=True
)

_likeCompoundPrimaryKey = TypedDict(
    '_likeCompoundPrimaryKey',
    {
        'article_id_user_id': '_likeCompoundPrimaryKeyInner',
    },
    total=True
)

likeWhereUniqueInput = _likeCompoundPrimaryKey


class likeUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    created_at: datetime.datetime
    updated_at: datetime.datetime
    article: 'articleUpdateOneWithoutRelationsInput'
    user: 'userUpdateOneWithoutRelationsInput'


class likeUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    created_at: datetime.datetime
    updated_at: datetime.datetime


class likeUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['likeCreateWithoutRelationsInput']
    connect: List['likeWhereUniqueInput']
    connect_or_create: List['likeConnectOrCreateWithoutRelationsInput']
    set: List['likeWhereUniqueInput']
    disconnect: List['likeWhereUniqueInput']
    delete: List['likeWhereUniqueInput']

    # TODO
    # update: List['likeUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['likeUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['likeScalarWhereInput']
    # upsert: List['likeUpserteWithWhereUniqueWithoutRelationsInput']


class likeUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'likeCreateWithoutRelationsInput'
    connect: 'likeWhereUniqueInput'
    connect_or_create: 'likeConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'likeUpdateInput'
    # upsert: 'likeUpsertWithoutRelationsInput'


class likeUpsertInput(TypedDict):
    create: 'likeCreateInput'
    update: 'likeUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_like_created_at_OrderByInput = TypedDict(
    '_like_created_at_OrderByInput',
    {
        'created_at': 'SortOrder',
    },
    total=True
)

_like_updated_at_OrderByInput = TypedDict(
    '_like_updated_at_OrderByInput',
    {
        'updated_at': 'SortOrder',
    },
    total=True
)

_like_article_id_OrderByInput = TypedDict(
    '_like_article_id_OrderByInput',
    {
        'article_id': 'SortOrder',
    },
    total=True
)

_like_user_id_OrderByInput = TypedDict(
    '_like_user_id_OrderByInput',
    {
        'user_id': 'SortOrder',
    },
    total=True
)

_like_RelevanceInner = TypedDict(
    '_like_RelevanceInner',
    {
        'fields': 'List[likeScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_like_RelevanceOrderByInput = TypedDict(
    '_like_RelevanceOrderByInput',
    {
        '_relevance': '_like_RelevanceInner',
    },
    total=True
)

likeOrderByInput = Union[
    '_like_created_at_OrderByInput',
    '_like_updated_at_OrderByInput',
    '_like_article_id_OrderByInput',
    '_like_user_id_OrderByInput',
    '_like_RelevanceOrderByInput',
]



# recursive like types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

likeRelationFilter = TypedDict(
    'likeRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class likeListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class likeInclude(TypedDict, total=False):
    """like relational arguments"""
    article: Union[bool, 'articleArgsFromlike']
    user: Union[bool, 'userArgsFromlike']


    

class userIncludeFromlike(TypedDict, total=False):
    """Relational arguments for like"""
    articles: Union[bool, 'FindManyarticleArgsFromlikeRecursive1']
    comments: Union[bool, 'FindManycommentArgsFromlikeRecursive1']
    likes: Union[bool, 'FindManylikeArgsFromlikeRecursive1']


class userIncludeFromlikeRecursive1(TypedDict, total=False):
    """Relational arguments for like"""
    articles: Union[bool, 'FindManyarticleArgsFromlikeRecursive2']
    comments: Union[bool, 'FindManycommentArgsFromlikeRecursive2']
    likes: Union[bool, 'FindManylikeArgsFromlikeRecursive2']


class userIncludeFromlikeRecursive2(TypedDict, total=False):
    """Relational arguments for like"""
    articles: Union[bool, 'FindManyarticleArgsFromlikeRecursive3']
    comments: Union[bool, 'FindManycommentArgsFromlikeRecursive3']
    likes: Union[bool, 'FindManylikeArgsFromlikeRecursive3']


class userIncludeFromlikeRecursive3(TypedDict, total=False):
    """Relational arguments for like"""
    articles: Union[bool, 'FindManyarticleArgsFromlikeRecursive4']
    comments: Union[bool, 'FindManycommentArgsFromlikeRecursive4']
    likes: Union[bool, 'FindManylikeArgsFromlikeRecursive4']


class userIncludeFromlikeRecursive4(TypedDict, total=False):
    """Relational arguments for like"""

    

class userArgsFromlike(TypedDict, total=False):
    """Arguments for like"""
    include: 'userIncludeFromuserRecursive1'


class userArgsFromlikeRecursive1(TypedDict, total=False):
    """Arguments for like"""
    include: 'userIncludeFromuserRecursive2'


class userArgsFromlikeRecursive2(TypedDict, total=False):
    """Arguments for like"""
    include: 'userIncludeFromuserRecursive3'


class userArgsFromlikeRecursive3(TypedDict, total=False):
    """Arguments for like"""
    include: 'userIncludeFromuserRecursive4'


class userArgsFromlikeRecursive4(TypedDict, total=False):
    """Arguments for like"""
    
    

class FindManyuserArgsFromlike(TypedDict, total=False):
    """Arguments for like"""
    take: int
    skip: int
    order_by: Union['userOrderByInput', List['userOrderByInput']]
    where: 'userWhereInput'
    cursor: 'userWhereUniqueInput'
    distinct: List['userScalarFieldKeys']
    include: 'userIncludeFromuserRecursive1'


class FindManyuserArgsFromlikeRecursive1(TypedDict, total=False):
    """Arguments for like"""
    take: int
    skip: int
    order_by: Union['userOrderByInput', List['userOrderByInput']]
    where: 'userWhereInput'
    cursor: 'userWhereUniqueInput'
    distinct: List['userScalarFieldKeys']
    include: 'userIncludeFromuserRecursive2'


class FindManyuserArgsFromlikeRecursive2(TypedDict, total=False):
    """Arguments for like"""
    take: int
    skip: int
    order_by: Union['userOrderByInput', List['userOrderByInput']]
    where: 'userWhereInput'
    cursor: 'userWhereUniqueInput'
    distinct: List['userScalarFieldKeys']
    include: 'userIncludeFromuserRecursive3'


class FindManyuserArgsFromlikeRecursive3(TypedDict, total=False):
    """Arguments for like"""
    take: int
    skip: int
    order_by: Union['userOrderByInput', List['userOrderByInput']]
    where: 'userWhereInput'
    cursor: 'userWhereUniqueInput'
    distinct: List['userScalarFieldKeys']
    include: 'userIncludeFromuserRecursive4'


class FindManyuserArgsFromlikeRecursive4(TypedDict, total=False):
    """Arguments for like"""
    take: int
    skip: int
    order_by: Union['userOrderByInput', List['userOrderByInput']]
    where: 'userWhereInput'
    cursor: 'userWhereUniqueInput'
    distinct: List['userScalarFieldKeys']
    
    

class articleIncludeFromlike(TypedDict, total=False):
    """Relational arguments for like"""
    user: Union[bool, 'userArgsFromlikeRecursive1']
    comments: Union[bool, 'FindManycommentArgsFromlikeRecursive1']
    likes: Union[bool, 'FindManylikeArgsFromlikeRecursive1']
    categories: Union[bool, 'FindManycategory_to_articleArgsFromlikeRecursive1']
    files: Union[bool, 'FindManyfileArgsFromlikeRecursive1']


class articleIncludeFromlikeRecursive1(TypedDict, total=False):
    """Relational arguments for like"""
    user: Union[bool, 'userArgsFromlikeRecursive2']
    comments: Union[bool, 'FindManycommentArgsFromlikeRecursive2']
    likes: Union[bool, 'FindManylikeArgsFromlikeRecursive2']
    categories: Union[bool, 'FindManycategory_to_articleArgsFromlikeRecursive2']
    files: Union[bool, 'FindManyfileArgsFromlikeRecursive2']


class articleIncludeFromlikeRecursive2(TypedDict, total=False):
    """Relational arguments for like"""
    user: Union[bool, 'userArgsFromlikeRecursive3']
    comments: Union[bool, 'FindManycommentArgsFromlikeRecursive3']
    likes: Union[bool, 'FindManylikeArgsFromlikeRecursive3']
    categories: Union[bool, 'FindManycategory_to_articleArgsFromlikeRecursive3']
    files: Union[bool, 'FindManyfileArgsFromlikeRecursive3']


class articleIncludeFromlikeRecursive3(TypedDict, total=False):
    """Relational arguments for like"""
    user: Union[bool, 'userArgsFromlikeRecursive4']
    comments: Union[bool, 'FindManycommentArgsFromlikeRecursive4']
    likes: Union[bool, 'FindManylikeArgsFromlikeRecursive4']
    categories: Union[bool, 'FindManycategory_to_articleArgsFromlikeRecursive4']
    files: Union[bool, 'FindManyfileArgsFromlikeRecursive4']


class articleIncludeFromlikeRecursive4(TypedDict, total=False):
    """Relational arguments for like"""

    

class articleArgsFromlike(TypedDict, total=False):
    """Arguments for like"""
    include: 'articleIncludeFromarticleRecursive1'


class articleArgsFromlikeRecursive1(TypedDict, total=False):
    """Arguments for like"""
    include: 'articleIncludeFromarticleRecursive2'


class articleArgsFromlikeRecursive2(TypedDict, total=False):
    """Arguments for like"""
    include: 'articleIncludeFromarticleRecursive3'


class articleArgsFromlikeRecursive3(TypedDict, total=False):
    """Arguments for like"""
    include: 'articleIncludeFromarticleRecursive4'


class articleArgsFromlikeRecursive4(TypedDict, total=False):
    """Arguments for like"""
    
    

class FindManyarticleArgsFromlike(TypedDict, total=False):
    """Arguments for like"""
    take: int
    skip: int
    order_by: Union['articleOrderByInput', List['articleOrderByInput']]
    where: 'articleWhereInput'
    cursor: 'articleWhereUniqueInput'
    distinct: List['articleScalarFieldKeys']
    include: 'articleIncludeFromarticleRecursive1'


class FindManyarticleArgsFromlikeRecursive1(TypedDict, total=False):
    """Arguments for like"""
    take: int
    skip: int
    order_by: Union['articleOrderByInput', List['articleOrderByInput']]
    where: 'articleWhereInput'
    cursor: 'articleWhereUniqueInput'
    distinct: List['articleScalarFieldKeys']
    include: 'articleIncludeFromarticleRecursive2'


class FindManyarticleArgsFromlikeRecursive2(TypedDict, total=False):
    """Arguments for like"""
    take: int
    skip: int
    order_by: Union['articleOrderByInput', List['articleOrderByInput']]
    where: 'articleWhereInput'
    cursor: 'articleWhereUniqueInput'
    distinct: List['articleScalarFieldKeys']
    include: 'articleIncludeFromarticleRecursive3'


class FindManyarticleArgsFromlikeRecursive3(TypedDict, total=False):
    """Arguments for like"""
    take: int
    skip: int
    order_by: Union['articleOrderByInput', List['articleOrderByInput']]
    where: 'articleWhereInput'
    cursor: 'articleWhereUniqueInput'
    distinct: List['articleScalarFieldKeys']
    include: 'articleIncludeFromarticleRecursive4'


class FindManyarticleArgsFromlikeRecursive4(TypedDict, total=False):
    """Arguments for like"""
    take: int
    skip: int
    order_by: Union['articleOrderByInput', List['articleOrderByInput']]
    where: 'articleWhereInput'
    cursor: 'articleWhereUniqueInput'
    distinct: List['articleScalarFieldKeys']
    
    

class categoryIncludeFromlike(TypedDict, total=False):
    """Relational arguments for like"""
    articles: Union[bool, 'FindManycategory_to_articleArgsFromlikeRecursive1']


class categoryIncludeFromlikeRecursive1(TypedDict, total=False):
    """Relational arguments for like"""
    articles: Union[bool, 'FindManycategory_to_articleArgsFromlikeRecursive2']


class categoryIncludeFromlikeRecursive2(TypedDict, total=False):
    """Relational arguments for like"""
    articles: Union[bool, 'FindManycategory_to_articleArgsFromlikeRecursive3']


class categoryIncludeFromlikeRecursive3(TypedDict, total=False):
    """Relational arguments for like"""
    articles: Union[bool, 'FindManycategory_to_articleArgsFromlikeRecursive4']


class categoryIncludeFromlikeRecursive4(TypedDict, total=False):
    """Relational arguments for like"""

    

class categoryArgsFromlike(TypedDict, total=False):
    """Arguments for like"""
    include: 'categoryIncludeFromcategoryRecursive1'


class categoryArgsFromlikeRecursive1(TypedDict, total=False):
    """Arguments for like"""
    include: 'categoryIncludeFromcategoryRecursive2'


class categoryArgsFromlikeRecursive2(TypedDict, total=False):
    """Arguments for like"""
    include: 'categoryIncludeFromcategoryRecursive3'


class categoryArgsFromlikeRecursive3(TypedDict, total=False):
    """Arguments for like"""
    include: 'categoryIncludeFromcategoryRecursive4'


class categoryArgsFromlikeRecursive4(TypedDict, total=False):
    """Arguments for like"""
    
    

class FindManycategoryArgsFromlike(TypedDict, total=False):
    """Arguments for like"""
    take: int
    skip: int
    order_by: Union['categoryOrderByInput', List['categoryOrderByInput']]
    where: 'categoryWhereInput'
    cursor: 'categoryWhereUniqueInput'
    distinct: List['categoryScalarFieldKeys']
    include: 'categoryIncludeFromcategoryRecursive1'


class FindManycategoryArgsFromlikeRecursive1(TypedDict, total=False):
    """Arguments for like"""
    take: int
    skip: int
    order_by: Union['categoryOrderByInput', List['categoryOrderByInput']]
    where: 'categoryWhereInput'
    cursor: 'categoryWhereUniqueInput'
    distinct: List['categoryScalarFieldKeys']
    include: 'categoryIncludeFromcategoryRecursive2'


class FindManycategoryArgsFromlikeRecursive2(TypedDict, total=False):
    """Arguments for like"""
    take: int
    skip: int
    order_by: Union['categoryOrderByInput', List['categoryOrderByInput']]
    where: 'categoryWhereInput'
    cursor: 'categoryWhereUniqueInput'
    distinct: List['categoryScalarFieldKeys']
    include: 'categoryIncludeFromcategoryRecursive3'


class FindManycategoryArgsFromlikeRecursive3(TypedDict, total=False):
    """Arguments for like"""
    take: int
    skip: int
    order_by: Union['categoryOrderByInput', List['categoryOrderByInput']]
    where: 'categoryWhereInput'
    cursor: 'categoryWhereUniqueInput'
    distinct: List['categoryScalarFieldKeys']
    include: 'categoryIncludeFromcategoryRecursive4'


class FindManycategoryArgsFromlikeRecursive4(TypedDict, total=False):
    """Arguments for like"""
    take: int
    skip: int
    order_by: Union['categoryOrderByInput', List['categoryOrderByInput']]
    where: 'categoryWhereInput'
    cursor: 'categoryWhereUniqueInput'
    distinct: List['categoryScalarFieldKeys']
    
    

class category_to_articleIncludeFromlike(TypedDict, total=False):
    """Relational arguments for like"""
    article: Union[bool, 'articleArgsFromlikeRecursive1']
    category: Union[bool, 'categoryArgsFromlikeRecursive1']


class category_to_articleIncludeFromlikeRecursive1(TypedDict, total=False):
    """Relational arguments for like"""
    article: Union[bool, 'articleArgsFromlikeRecursive2']
    category: Union[bool, 'categoryArgsFromlikeRecursive2']


class category_to_articleIncludeFromlikeRecursive2(TypedDict, total=False):
    """Relational arguments for like"""
    article: Union[bool, 'articleArgsFromlikeRecursive3']
    category: Union[bool, 'categoryArgsFromlikeRecursive3']


class category_to_articleIncludeFromlikeRecursive3(TypedDict, total=False):
    """Relational arguments for like"""
    article: Union[bool, 'articleArgsFromlikeRecursive4']
    category: Union[bool, 'categoryArgsFromlikeRecursive4']


class category_to_articleIncludeFromlikeRecursive4(TypedDict, total=False):
    """Relational arguments for like"""

    

class category_to_articleArgsFromlike(TypedDict, total=False):
    """Arguments for like"""
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive1'


class category_to_articleArgsFromlikeRecursive1(TypedDict, total=False):
    """Arguments for like"""
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive2'


class category_to_articleArgsFromlikeRecursive2(TypedDict, total=False):
    """Arguments for like"""
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive3'


class category_to_articleArgsFromlikeRecursive3(TypedDict, total=False):
    """Arguments for like"""
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive4'


class category_to_articleArgsFromlikeRecursive4(TypedDict, total=False):
    """Arguments for like"""
    
    

class FindManycategory_to_articleArgsFromlike(TypedDict, total=False):
    """Arguments for like"""
    take: int
    skip: int
    order_by: Union['category_to_articleOrderByInput', List['category_to_articleOrderByInput']]
    where: 'category_to_articleWhereInput'
    cursor: 'category_to_articleWhereUniqueInput'
    distinct: List['category_to_articleScalarFieldKeys']
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive1'


class FindManycategory_to_articleArgsFromlikeRecursive1(TypedDict, total=False):
    """Arguments for like"""
    take: int
    skip: int
    order_by: Union['category_to_articleOrderByInput', List['category_to_articleOrderByInput']]
    where: 'category_to_articleWhereInput'
    cursor: 'category_to_articleWhereUniqueInput'
    distinct: List['category_to_articleScalarFieldKeys']
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive2'


class FindManycategory_to_articleArgsFromlikeRecursive2(TypedDict, total=False):
    """Arguments for like"""
    take: int
    skip: int
    order_by: Union['category_to_articleOrderByInput', List['category_to_articleOrderByInput']]
    where: 'category_to_articleWhereInput'
    cursor: 'category_to_articleWhereUniqueInput'
    distinct: List['category_to_articleScalarFieldKeys']
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive3'


class FindManycategory_to_articleArgsFromlikeRecursive3(TypedDict, total=False):
    """Arguments for like"""
    take: int
    skip: int
    order_by: Union['category_to_articleOrderByInput', List['category_to_articleOrderByInput']]
    where: 'category_to_articleWhereInput'
    cursor: 'category_to_articleWhereUniqueInput'
    distinct: List['category_to_articleScalarFieldKeys']
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive4'


class FindManycategory_to_articleArgsFromlikeRecursive4(TypedDict, total=False):
    """Arguments for like"""
    take: int
    skip: int
    order_by: Union['category_to_articleOrderByInput', List['category_to_articleOrderByInput']]
    where: 'category_to_articleWhereInput'
    cursor: 'category_to_articleWhereUniqueInput'
    distinct: List['category_to_articleScalarFieldKeys']
    
    

class commentIncludeFromlike(TypedDict, total=False):
    """Relational arguments for like"""
    article: Union[bool, 'articleArgsFromlikeRecursive1']
    user: Union[bool, 'userArgsFromlikeRecursive1']


class commentIncludeFromlikeRecursive1(TypedDict, total=False):
    """Relational arguments for like"""
    article: Union[bool, 'articleArgsFromlikeRecursive2']
    user: Union[bool, 'userArgsFromlikeRecursive2']


class commentIncludeFromlikeRecursive2(TypedDict, total=False):
    """Relational arguments for like"""
    article: Union[bool, 'articleArgsFromlikeRecursive3']
    user: Union[bool, 'userArgsFromlikeRecursive3']


class commentIncludeFromlikeRecursive3(TypedDict, total=False):
    """Relational arguments for like"""
    article: Union[bool, 'articleArgsFromlikeRecursive4']
    user: Union[bool, 'userArgsFromlikeRecursive4']


class commentIncludeFromlikeRecursive4(TypedDict, total=False):
    """Relational arguments for like"""

    

class commentArgsFromlike(TypedDict, total=False):
    """Arguments for like"""
    include: 'commentIncludeFromcommentRecursive1'


class commentArgsFromlikeRecursive1(TypedDict, total=False):
    """Arguments for like"""
    include: 'commentIncludeFromcommentRecursive2'


class commentArgsFromlikeRecursive2(TypedDict, total=False):
    """Arguments for like"""
    include: 'commentIncludeFromcommentRecursive3'


class commentArgsFromlikeRecursive3(TypedDict, total=False):
    """Arguments for like"""
    include: 'commentIncludeFromcommentRecursive4'


class commentArgsFromlikeRecursive4(TypedDict, total=False):
    """Arguments for like"""
    
    

class FindManycommentArgsFromlike(TypedDict, total=False):
    """Arguments for like"""
    take: int
    skip: int
    order_by: Union['commentOrderByInput', List['commentOrderByInput']]
    where: 'commentWhereInput'
    cursor: 'commentWhereUniqueInput'
    distinct: List['commentScalarFieldKeys']
    include: 'commentIncludeFromcommentRecursive1'


class FindManycommentArgsFromlikeRecursive1(TypedDict, total=False):
    """Arguments for like"""
    take: int
    skip: int
    order_by: Union['commentOrderByInput', List['commentOrderByInput']]
    where: 'commentWhereInput'
    cursor: 'commentWhereUniqueInput'
    distinct: List['commentScalarFieldKeys']
    include: 'commentIncludeFromcommentRecursive2'


class FindManycommentArgsFromlikeRecursive2(TypedDict, total=False):
    """Arguments for like"""
    take: int
    skip: int
    order_by: Union['commentOrderByInput', List['commentOrderByInput']]
    where: 'commentWhereInput'
    cursor: 'commentWhereUniqueInput'
    distinct: List['commentScalarFieldKeys']
    include: 'commentIncludeFromcommentRecursive3'


class FindManycommentArgsFromlikeRecursive3(TypedDict, total=False):
    """Arguments for like"""
    take: int
    skip: int
    order_by: Union['commentOrderByInput', List['commentOrderByInput']]
    where: 'commentWhereInput'
    cursor: 'commentWhereUniqueInput'
    distinct: List['commentScalarFieldKeys']
    include: 'commentIncludeFromcommentRecursive4'


class FindManycommentArgsFromlikeRecursive4(TypedDict, total=False):
    """Arguments for like"""
    take: int
    skip: int
    order_by: Union['commentOrderByInput', List['commentOrderByInput']]
    where: 'commentWhereInput'
    cursor: 'commentWhereUniqueInput'
    distinct: List['commentScalarFieldKeys']
    
    

class likeIncludeFromlike(TypedDict, total=False):
    """Relational arguments for like"""
    article: Union[bool, 'articleArgsFromlikeRecursive1']
    user: Union[bool, 'userArgsFromlikeRecursive1']


class likeIncludeFromlikeRecursive1(TypedDict, total=False):
    """Relational arguments for like"""
    article: Union[bool, 'articleArgsFromlikeRecursive2']
    user: Union[bool, 'userArgsFromlikeRecursive2']


class likeIncludeFromlikeRecursive2(TypedDict, total=False):
    """Relational arguments for like"""
    article: Union[bool, 'articleArgsFromlikeRecursive3']
    user: Union[bool, 'userArgsFromlikeRecursive3']


class likeIncludeFromlikeRecursive3(TypedDict, total=False):
    """Relational arguments for like"""
    article: Union[bool, 'articleArgsFromlikeRecursive4']
    user: Union[bool, 'userArgsFromlikeRecursive4']


class likeIncludeFromlikeRecursive4(TypedDict, total=False):
    """Relational arguments for like"""

    

class likeArgsFromlike(TypedDict, total=False):
    """Arguments for like"""
    include: 'likeIncludeFromlikeRecursive1'


class likeArgsFromlikeRecursive1(TypedDict, total=False):
    """Arguments for like"""
    include: 'likeIncludeFromlikeRecursive2'


class likeArgsFromlikeRecursive2(TypedDict, total=False):
    """Arguments for like"""
    include: 'likeIncludeFromlikeRecursive3'


class likeArgsFromlikeRecursive3(TypedDict, total=False):
    """Arguments for like"""
    include: 'likeIncludeFromlikeRecursive4'


class likeArgsFromlikeRecursive4(TypedDict, total=False):
    """Arguments for like"""
    
    

class FindManylikeArgsFromlike(TypedDict, total=False):
    """Arguments for like"""
    take: int
    skip: int
    order_by: Union['likeOrderByInput', List['likeOrderByInput']]
    where: 'likeWhereInput'
    cursor: 'likeWhereUniqueInput'
    distinct: List['likeScalarFieldKeys']
    include: 'likeIncludeFromlikeRecursive1'


class FindManylikeArgsFromlikeRecursive1(TypedDict, total=False):
    """Arguments for like"""
    take: int
    skip: int
    order_by: Union['likeOrderByInput', List['likeOrderByInput']]
    where: 'likeWhereInput'
    cursor: 'likeWhereUniqueInput'
    distinct: List['likeScalarFieldKeys']
    include: 'likeIncludeFromlikeRecursive2'


class FindManylikeArgsFromlikeRecursive2(TypedDict, total=False):
    """Arguments for like"""
    take: int
    skip: int
    order_by: Union['likeOrderByInput', List['likeOrderByInput']]
    where: 'likeWhereInput'
    cursor: 'likeWhereUniqueInput'
    distinct: List['likeScalarFieldKeys']
    include: 'likeIncludeFromlikeRecursive3'


class FindManylikeArgsFromlikeRecursive3(TypedDict, total=False):
    """Arguments for like"""
    take: int
    skip: int
    order_by: Union['likeOrderByInput', List['likeOrderByInput']]
    where: 'likeWhereInput'
    cursor: 'likeWhereUniqueInput'
    distinct: List['likeScalarFieldKeys']
    include: 'likeIncludeFromlikeRecursive4'


class FindManylikeArgsFromlikeRecursive4(TypedDict, total=False):
    """Arguments for like"""
    take: int
    skip: int
    order_by: Union['likeOrderByInput', List['likeOrderByInput']]
    where: 'likeWhereInput'
    cursor: 'likeWhereUniqueInput'
    distinct: List['likeScalarFieldKeys']
    
    

class fileIncludeFromlike(TypedDict, total=False):
    """Relational arguments for like"""
    article: Union[bool, 'articleArgsFromlikeRecursive1']


class fileIncludeFromlikeRecursive1(TypedDict, total=False):
    """Relational arguments for like"""
    article: Union[bool, 'articleArgsFromlikeRecursive2']


class fileIncludeFromlikeRecursive2(TypedDict, total=False):
    """Relational arguments for like"""
    article: Union[bool, 'articleArgsFromlikeRecursive3']


class fileIncludeFromlikeRecursive3(TypedDict, total=False):
    """Relational arguments for like"""
    article: Union[bool, 'articleArgsFromlikeRecursive4']


class fileIncludeFromlikeRecursive4(TypedDict, total=False):
    """Relational arguments for like"""

    

class fileArgsFromlike(TypedDict, total=False):
    """Arguments for like"""
    include: 'fileIncludeFromfileRecursive1'


class fileArgsFromlikeRecursive1(TypedDict, total=False):
    """Arguments for like"""
    include: 'fileIncludeFromfileRecursive2'


class fileArgsFromlikeRecursive2(TypedDict, total=False):
    """Arguments for like"""
    include: 'fileIncludeFromfileRecursive3'


class fileArgsFromlikeRecursive3(TypedDict, total=False):
    """Arguments for like"""
    include: 'fileIncludeFromfileRecursive4'


class fileArgsFromlikeRecursive4(TypedDict, total=False):
    """Arguments for like"""
    
    

class FindManyfileArgsFromlike(TypedDict, total=False):
    """Arguments for like"""
    take: int
    skip: int
    order_by: Union['fileOrderByInput', List['fileOrderByInput']]
    where: 'fileWhereInput'
    cursor: 'fileWhereUniqueInput'
    distinct: List['fileScalarFieldKeys']
    include: 'fileIncludeFromfileRecursive1'


class FindManyfileArgsFromlikeRecursive1(TypedDict, total=False):
    """Arguments for like"""
    take: int
    skip: int
    order_by: Union['fileOrderByInput', List['fileOrderByInput']]
    where: 'fileWhereInput'
    cursor: 'fileWhereUniqueInput'
    distinct: List['fileScalarFieldKeys']
    include: 'fileIncludeFromfileRecursive2'


class FindManyfileArgsFromlikeRecursive2(TypedDict, total=False):
    """Arguments for like"""
    take: int
    skip: int
    order_by: Union['fileOrderByInput', List['fileOrderByInput']]
    where: 'fileWhereInput'
    cursor: 'fileWhereUniqueInput'
    distinct: List['fileScalarFieldKeys']
    include: 'fileIncludeFromfileRecursive3'


class FindManyfileArgsFromlikeRecursive3(TypedDict, total=False):
    """Arguments for like"""
    take: int
    skip: int
    order_by: Union['fileOrderByInput', List['fileOrderByInput']]
    where: 'fileWhereInput'
    cursor: 'fileWhereUniqueInput'
    distinct: List['fileScalarFieldKeys']
    include: 'fileIncludeFromfileRecursive4'


class FindManyfileArgsFromlikeRecursive4(TypedDict, total=False):
    """Arguments for like"""
    take: int
    skip: int
    order_by: Union['fileOrderByInput', List['fileOrderByInput']]
    where: 'fileWhereInput'
    cursor: 'fileWhereUniqueInput'
    distinct: List['fileScalarFieldKeys']
    


FindManylikeArgs = FindManylikeArgsFromlike
FindFirstlikeArgs = FindManylikeArgsFromlike


    

class likeWhereInput(TypedDict, total=False):
    """like arguments for searching"""
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    article_id: Union[_int, 'types.IntFilter']
    user_id: Union[_int, 'types.IntFilter']
    article: 'articleRelationFilter'
    user: 'userRelationFilter'

    # should be noted that AND and NOT should be Union['likeWhereInputRecursive1', List['likeWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['likeWhereInputRecursive1']
    OR: List['likeWhereInputRecursive1']
    NOT: List['likeWhereInputRecursive1']


class likeWhereInputRecursive1(TypedDict, total=False):
    """like arguments for searching"""
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    article_id: Union[_int, 'types.IntFilter']
    user_id: Union[_int, 'types.IntFilter']
    article: 'articleRelationFilter'
    user: 'userRelationFilter'

    # should be noted that AND and NOT should be Union['likeWhereInputRecursive2', List['likeWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['likeWhereInputRecursive2']
    OR: List['likeWhereInputRecursive2']
    NOT: List['likeWhereInputRecursive2']


class likeWhereInputRecursive2(TypedDict, total=False):
    """like arguments for searching"""
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    article_id: Union[_int, 'types.IntFilter']
    user_id: Union[_int, 'types.IntFilter']
    article: 'articleRelationFilter'
    user: 'userRelationFilter'

    # should be noted that AND and NOT should be Union['likeWhereInputRecursive3', List['likeWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['likeWhereInputRecursive3']
    OR: List['likeWhereInputRecursive3']
    NOT: List['likeWhereInputRecursive3']


class likeWhereInputRecursive3(TypedDict, total=False):
    """like arguments for searching"""
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    article_id: Union[_int, 'types.IntFilter']
    user_id: Union[_int, 'types.IntFilter']
    article: 'articleRelationFilter'
    user: 'userRelationFilter'

    # should be noted that AND and NOT should be Union['likeWhereInputRecursive4', List['likeWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['likeWhereInputRecursive4']
    OR: List['likeWhereInputRecursive4']
    NOT: List['likeWhereInputRecursive4']


class likeWhereInputRecursive4(TypedDict, total=False):
    """like arguments for searching"""
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    article_id: Union[_int, 'types.IntFilter']
    user_id: Union[_int, 'types.IntFilter']
    article: 'articleRelationFilter'
    user: 'userRelationFilter'



# aggregate like types


    

class likeScalarWhereWithAggregatesInput(TypedDict, total=False):
    """like arguments for searching"""
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    article_id: Union[_int, 'types.IntWithAggregatesFilter']
    user_id: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['likeScalarWhereWithAggregatesInputRecursive1']
    OR: List['likeScalarWhereWithAggregatesInputRecursive1']
    NOT: List['likeScalarWhereWithAggregatesInputRecursive1']


class likeScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """like arguments for searching"""
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    article_id: Union[_int, 'types.IntWithAggregatesFilter']
    user_id: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['likeScalarWhereWithAggregatesInputRecursive2']
    OR: List['likeScalarWhereWithAggregatesInputRecursive2']
    NOT: List['likeScalarWhereWithAggregatesInputRecursive2']


class likeScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """like arguments for searching"""
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    article_id: Union[_int, 'types.IntWithAggregatesFilter']
    user_id: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['likeScalarWhereWithAggregatesInputRecursive3']
    OR: List['likeScalarWhereWithAggregatesInputRecursive3']
    NOT: List['likeScalarWhereWithAggregatesInputRecursive3']


class likeScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """like arguments for searching"""
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    article_id: Union[_int, 'types.IntWithAggregatesFilter']
    user_id: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['likeScalarWhereWithAggregatesInputRecursive4']
    OR: List['likeScalarWhereWithAggregatesInputRecursive4']
    NOT: List['likeScalarWhereWithAggregatesInputRecursive4']


class likeScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """like arguments for searching"""
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    article_id: Union[_int, 'types.IntWithAggregatesFilter']
    user_id: Union[_int, 'types.IntWithAggregatesFilter']



class likeGroupByOutput(TypedDict, total=False):
    created_at: datetime.datetime
    updated_at: datetime.datetime
    article_id: _int
    user_id: _int
    _sum: 'likeSumAggregateOutput'
    _avg: 'likeAvgAggregateOutput'
    _min: 'likeMinAggregateOutput'
    _max: 'likeMaxAggregateOutput'
    _count: 'likeCountAggregateOutput'


class likeAvgAggregateOutput(TypedDict, total=False):
    """like output for aggregating averages"""
    article_id: float
    user_id: float


class likeSumAggregateOutput(TypedDict, total=False):
    """like output for aggregating sums"""
    article_id: _int
    user_id: _int


class likeScalarAggregateOutput(TypedDict, total=False):
    """like output including scalar fields"""
    created_at: datetime.datetime
    updated_at: datetime.datetime
    article_id: _int
    user_id: _int


likeMinAggregateOutput = likeScalarAggregateOutput
likeMaxAggregateOutput = likeScalarAggregateOutput


class likeMaxAggregateInput(TypedDict, total=False):
    """like input for aggregating by max"""
    created_at: bool
    updated_at: bool
    article_id: bool
    user_id: bool


class likeMinAggregateInput(TypedDict, total=False):
    """like input for aggregating by min"""
    created_at: bool
    updated_at: bool
    article_id: bool
    user_id: bool


class likeNumberAggregateInput(TypedDict, total=False):
    """like input for aggregating numbers"""
    article_id: bool
    user_id: bool


likeAvgAggregateInput = likeNumberAggregateInput
likeSumAggregateInput = likeNumberAggregateInput


likeCountAggregateInput = TypedDict(
    'likeCountAggregateInput',
    {
        'created_at': bool,
        'updated_at': bool,
        'article_id': bool,
        'user_id': bool,
        '_all': bool,
    },
    total=False,
)

likeCountAggregateOutput = TypedDict(
    'likeCountAggregateOutput',
    {
        'created_at': int,
        'updated_at': int,
        'article_id': int,
        'user_id': int,
        '_all': int,
    },
    total=False,
)


likeKeys = Literal[
    'created_at',
    'updated_at',
    'article_id',
    'user_id',
    'article',
    'user',
]
likeScalarFieldKeys = Literal[
    'created_at',
    'updated_at',
    'article_id',
    'user_id',
]
likeScalarFieldKeysT = TypeVar('likeScalarFieldKeysT', bound=likeScalarFieldKeys)

likeRelationalFieldKeys = Literal[
        'article',
        'user',
    ]

# file types

class fileOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the file create method"""
    id: _int
    created_at: datetime.datetime
    updated_at: datetime.datetime
    article_id: _int
    article: 'articleCreateNestedWithoutRelationsInput'


class fileCreateInput(fileOptionalCreateInput):
    """Required arguments to the file create method"""
    path: _str
    filename: _str
    mimetype: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class fileOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the file create method, without relations"""
    id: _int
    created_at: datetime.datetime
    updated_at: datetime.datetime
    article_id: _int


class fileCreateWithoutRelationsInput(fileOptionalCreateWithoutRelationsInput):
    """Required arguments to the file create method, without relations"""
    path: _str
    filename: _str
    mimetype: _str

class fileConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'fileCreateWithoutRelationsInput'
    where: 'fileWhereUniqueInput'

class fileCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'fileCreateWithoutRelationsInput'
    connect: 'fileWhereUniqueInput'
    connect_or_create: 'fileConnectOrCreateWithoutRelationsInput'


class fileCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['fileCreateWithoutRelationsInput', List['fileCreateWithoutRelationsInput']]
    connect: Union['fileWhereUniqueInput', List['fileWhereUniqueInput']]
    connect_or_create: Union['fileConnectOrCreateWithoutRelationsInput', List['fileConnectOrCreateWithoutRelationsInput']]

_fileWhereUnique_id_Input = TypedDict(
    '_fileWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

fileWhereUniqueInput = _fileWhereUnique_id_Input


class fileUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    path: _str
    filename: _str
    mimetype: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    article: 'articleUpdateOneWithoutRelationsInput'


class fileUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    path: _str
    filename: _str
    mimetype: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime


class fileUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['fileCreateWithoutRelationsInput']
    connect: List['fileWhereUniqueInput']
    connect_or_create: List['fileConnectOrCreateWithoutRelationsInput']
    set: List['fileWhereUniqueInput']
    disconnect: List['fileWhereUniqueInput']
    delete: List['fileWhereUniqueInput']

    # TODO
    # update: List['fileUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['fileUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['fileScalarWhereInput']
    # upsert: List['fileUpserteWithWhereUniqueWithoutRelationsInput']


class fileUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'fileCreateWithoutRelationsInput'
    connect: 'fileWhereUniqueInput'
    connect_or_create: 'fileConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'fileUpdateInput'
    # upsert: 'fileUpsertWithoutRelationsInput'


class fileUpsertInput(TypedDict):
    create: 'fileCreateInput'
    update: 'fileUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_file_id_OrderByInput = TypedDict(
    '_file_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_file_path_OrderByInput = TypedDict(
    '_file_path_OrderByInput',
    {
        'path': 'SortOrder',
    },
    total=True
)

_file_filename_OrderByInput = TypedDict(
    '_file_filename_OrderByInput',
    {
        'filename': 'SortOrder',
    },
    total=True
)

_file_mimetype_OrderByInput = TypedDict(
    '_file_mimetype_OrderByInput',
    {
        'mimetype': 'SortOrder',
    },
    total=True
)

_file_created_at_OrderByInput = TypedDict(
    '_file_created_at_OrderByInput',
    {
        'created_at': 'SortOrder',
    },
    total=True
)

_file_updated_at_OrderByInput = TypedDict(
    '_file_updated_at_OrderByInput',
    {
        'updated_at': 'SortOrder',
    },
    total=True
)

_file_article_id_OrderByInput = TypedDict(
    '_file_article_id_OrderByInput',
    {
        'article_id': 'SortOrder',
    },
    total=True
)

_file_RelevanceInner = TypedDict(
    '_file_RelevanceInner',
    {
        'fields': 'List[fileScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_file_RelevanceOrderByInput = TypedDict(
    '_file_RelevanceOrderByInput',
    {
        '_relevance': '_file_RelevanceInner',
    },
    total=True
)

fileOrderByInput = Union[
    '_file_id_OrderByInput',
    '_file_path_OrderByInput',
    '_file_filename_OrderByInput',
    '_file_mimetype_OrderByInput',
    '_file_created_at_OrderByInput',
    '_file_updated_at_OrderByInput',
    '_file_article_id_OrderByInput',
    '_file_RelevanceOrderByInput',
]



# recursive file types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

fileRelationFilter = TypedDict(
    'fileRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class fileListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class fileInclude(TypedDict, total=False):
    """file relational arguments"""
    article: Union[bool, 'articleArgsFromfile']


    

class userIncludeFromfile(TypedDict, total=False):
    """Relational arguments for file"""
    articles: Union[bool, 'FindManyarticleArgsFromfileRecursive1']
    comments: Union[bool, 'FindManycommentArgsFromfileRecursive1']
    likes: Union[bool, 'FindManylikeArgsFromfileRecursive1']


class userIncludeFromfileRecursive1(TypedDict, total=False):
    """Relational arguments for file"""
    articles: Union[bool, 'FindManyarticleArgsFromfileRecursive2']
    comments: Union[bool, 'FindManycommentArgsFromfileRecursive2']
    likes: Union[bool, 'FindManylikeArgsFromfileRecursive2']


class userIncludeFromfileRecursive2(TypedDict, total=False):
    """Relational arguments for file"""
    articles: Union[bool, 'FindManyarticleArgsFromfileRecursive3']
    comments: Union[bool, 'FindManycommentArgsFromfileRecursive3']
    likes: Union[bool, 'FindManylikeArgsFromfileRecursive3']


class userIncludeFromfileRecursive3(TypedDict, total=False):
    """Relational arguments for file"""
    articles: Union[bool, 'FindManyarticleArgsFromfileRecursive4']
    comments: Union[bool, 'FindManycommentArgsFromfileRecursive4']
    likes: Union[bool, 'FindManylikeArgsFromfileRecursive4']


class userIncludeFromfileRecursive4(TypedDict, total=False):
    """Relational arguments for file"""

    

class userArgsFromfile(TypedDict, total=False):
    """Arguments for file"""
    include: 'userIncludeFromuserRecursive1'


class userArgsFromfileRecursive1(TypedDict, total=False):
    """Arguments for file"""
    include: 'userIncludeFromuserRecursive2'


class userArgsFromfileRecursive2(TypedDict, total=False):
    """Arguments for file"""
    include: 'userIncludeFromuserRecursive3'


class userArgsFromfileRecursive3(TypedDict, total=False):
    """Arguments for file"""
    include: 'userIncludeFromuserRecursive4'


class userArgsFromfileRecursive4(TypedDict, total=False):
    """Arguments for file"""
    
    

class FindManyuserArgsFromfile(TypedDict, total=False):
    """Arguments for file"""
    take: int
    skip: int
    order_by: Union['userOrderByInput', List['userOrderByInput']]
    where: 'userWhereInput'
    cursor: 'userWhereUniqueInput'
    distinct: List['userScalarFieldKeys']
    include: 'userIncludeFromuserRecursive1'


class FindManyuserArgsFromfileRecursive1(TypedDict, total=False):
    """Arguments for file"""
    take: int
    skip: int
    order_by: Union['userOrderByInput', List['userOrderByInput']]
    where: 'userWhereInput'
    cursor: 'userWhereUniqueInput'
    distinct: List['userScalarFieldKeys']
    include: 'userIncludeFromuserRecursive2'


class FindManyuserArgsFromfileRecursive2(TypedDict, total=False):
    """Arguments for file"""
    take: int
    skip: int
    order_by: Union['userOrderByInput', List['userOrderByInput']]
    where: 'userWhereInput'
    cursor: 'userWhereUniqueInput'
    distinct: List['userScalarFieldKeys']
    include: 'userIncludeFromuserRecursive3'


class FindManyuserArgsFromfileRecursive3(TypedDict, total=False):
    """Arguments for file"""
    take: int
    skip: int
    order_by: Union['userOrderByInput', List['userOrderByInput']]
    where: 'userWhereInput'
    cursor: 'userWhereUniqueInput'
    distinct: List['userScalarFieldKeys']
    include: 'userIncludeFromuserRecursive4'


class FindManyuserArgsFromfileRecursive4(TypedDict, total=False):
    """Arguments for file"""
    take: int
    skip: int
    order_by: Union['userOrderByInput', List['userOrderByInput']]
    where: 'userWhereInput'
    cursor: 'userWhereUniqueInput'
    distinct: List['userScalarFieldKeys']
    
    

class articleIncludeFromfile(TypedDict, total=False):
    """Relational arguments for file"""
    user: Union[bool, 'userArgsFromfileRecursive1']
    comments: Union[bool, 'FindManycommentArgsFromfileRecursive1']
    likes: Union[bool, 'FindManylikeArgsFromfileRecursive1']
    categories: Union[bool, 'FindManycategory_to_articleArgsFromfileRecursive1']
    files: Union[bool, 'FindManyfileArgsFromfileRecursive1']


class articleIncludeFromfileRecursive1(TypedDict, total=False):
    """Relational arguments for file"""
    user: Union[bool, 'userArgsFromfileRecursive2']
    comments: Union[bool, 'FindManycommentArgsFromfileRecursive2']
    likes: Union[bool, 'FindManylikeArgsFromfileRecursive2']
    categories: Union[bool, 'FindManycategory_to_articleArgsFromfileRecursive2']
    files: Union[bool, 'FindManyfileArgsFromfileRecursive2']


class articleIncludeFromfileRecursive2(TypedDict, total=False):
    """Relational arguments for file"""
    user: Union[bool, 'userArgsFromfileRecursive3']
    comments: Union[bool, 'FindManycommentArgsFromfileRecursive3']
    likes: Union[bool, 'FindManylikeArgsFromfileRecursive3']
    categories: Union[bool, 'FindManycategory_to_articleArgsFromfileRecursive3']
    files: Union[bool, 'FindManyfileArgsFromfileRecursive3']


class articleIncludeFromfileRecursive3(TypedDict, total=False):
    """Relational arguments for file"""
    user: Union[bool, 'userArgsFromfileRecursive4']
    comments: Union[bool, 'FindManycommentArgsFromfileRecursive4']
    likes: Union[bool, 'FindManylikeArgsFromfileRecursive4']
    categories: Union[bool, 'FindManycategory_to_articleArgsFromfileRecursive4']
    files: Union[bool, 'FindManyfileArgsFromfileRecursive4']


class articleIncludeFromfileRecursive4(TypedDict, total=False):
    """Relational arguments for file"""

    

class articleArgsFromfile(TypedDict, total=False):
    """Arguments for file"""
    include: 'articleIncludeFromarticleRecursive1'


class articleArgsFromfileRecursive1(TypedDict, total=False):
    """Arguments for file"""
    include: 'articleIncludeFromarticleRecursive2'


class articleArgsFromfileRecursive2(TypedDict, total=False):
    """Arguments for file"""
    include: 'articleIncludeFromarticleRecursive3'


class articleArgsFromfileRecursive3(TypedDict, total=False):
    """Arguments for file"""
    include: 'articleIncludeFromarticleRecursive4'


class articleArgsFromfileRecursive4(TypedDict, total=False):
    """Arguments for file"""
    
    

class FindManyarticleArgsFromfile(TypedDict, total=False):
    """Arguments for file"""
    take: int
    skip: int
    order_by: Union['articleOrderByInput', List['articleOrderByInput']]
    where: 'articleWhereInput'
    cursor: 'articleWhereUniqueInput'
    distinct: List['articleScalarFieldKeys']
    include: 'articleIncludeFromarticleRecursive1'


class FindManyarticleArgsFromfileRecursive1(TypedDict, total=False):
    """Arguments for file"""
    take: int
    skip: int
    order_by: Union['articleOrderByInput', List['articleOrderByInput']]
    where: 'articleWhereInput'
    cursor: 'articleWhereUniqueInput'
    distinct: List['articleScalarFieldKeys']
    include: 'articleIncludeFromarticleRecursive2'


class FindManyarticleArgsFromfileRecursive2(TypedDict, total=False):
    """Arguments for file"""
    take: int
    skip: int
    order_by: Union['articleOrderByInput', List['articleOrderByInput']]
    where: 'articleWhereInput'
    cursor: 'articleWhereUniqueInput'
    distinct: List['articleScalarFieldKeys']
    include: 'articleIncludeFromarticleRecursive3'


class FindManyarticleArgsFromfileRecursive3(TypedDict, total=False):
    """Arguments for file"""
    take: int
    skip: int
    order_by: Union['articleOrderByInput', List['articleOrderByInput']]
    where: 'articleWhereInput'
    cursor: 'articleWhereUniqueInput'
    distinct: List['articleScalarFieldKeys']
    include: 'articleIncludeFromarticleRecursive4'


class FindManyarticleArgsFromfileRecursive4(TypedDict, total=False):
    """Arguments for file"""
    take: int
    skip: int
    order_by: Union['articleOrderByInput', List['articleOrderByInput']]
    where: 'articleWhereInput'
    cursor: 'articleWhereUniqueInput'
    distinct: List['articleScalarFieldKeys']
    
    

class categoryIncludeFromfile(TypedDict, total=False):
    """Relational arguments for file"""
    articles: Union[bool, 'FindManycategory_to_articleArgsFromfileRecursive1']


class categoryIncludeFromfileRecursive1(TypedDict, total=False):
    """Relational arguments for file"""
    articles: Union[bool, 'FindManycategory_to_articleArgsFromfileRecursive2']


class categoryIncludeFromfileRecursive2(TypedDict, total=False):
    """Relational arguments for file"""
    articles: Union[bool, 'FindManycategory_to_articleArgsFromfileRecursive3']


class categoryIncludeFromfileRecursive3(TypedDict, total=False):
    """Relational arguments for file"""
    articles: Union[bool, 'FindManycategory_to_articleArgsFromfileRecursive4']


class categoryIncludeFromfileRecursive4(TypedDict, total=False):
    """Relational arguments for file"""

    

class categoryArgsFromfile(TypedDict, total=False):
    """Arguments for file"""
    include: 'categoryIncludeFromcategoryRecursive1'


class categoryArgsFromfileRecursive1(TypedDict, total=False):
    """Arguments for file"""
    include: 'categoryIncludeFromcategoryRecursive2'


class categoryArgsFromfileRecursive2(TypedDict, total=False):
    """Arguments for file"""
    include: 'categoryIncludeFromcategoryRecursive3'


class categoryArgsFromfileRecursive3(TypedDict, total=False):
    """Arguments for file"""
    include: 'categoryIncludeFromcategoryRecursive4'


class categoryArgsFromfileRecursive4(TypedDict, total=False):
    """Arguments for file"""
    
    

class FindManycategoryArgsFromfile(TypedDict, total=False):
    """Arguments for file"""
    take: int
    skip: int
    order_by: Union['categoryOrderByInput', List['categoryOrderByInput']]
    where: 'categoryWhereInput'
    cursor: 'categoryWhereUniqueInput'
    distinct: List['categoryScalarFieldKeys']
    include: 'categoryIncludeFromcategoryRecursive1'


class FindManycategoryArgsFromfileRecursive1(TypedDict, total=False):
    """Arguments for file"""
    take: int
    skip: int
    order_by: Union['categoryOrderByInput', List['categoryOrderByInput']]
    where: 'categoryWhereInput'
    cursor: 'categoryWhereUniqueInput'
    distinct: List['categoryScalarFieldKeys']
    include: 'categoryIncludeFromcategoryRecursive2'


class FindManycategoryArgsFromfileRecursive2(TypedDict, total=False):
    """Arguments for file"""
    take: int
    skip: int
    order_by: Union['categoryOrderByInput', List['categoryOrderByInput']]
    where: 'categoryWhereInput'
    cursor: 'categoryWhereUniqueInput'
    distinct: List['categoryScalarFieldKeys']
    include: 'categoryIncludeFromcategoryRecursive3'


class FindManycategoryArgsFromfileRecursive3(TypedDict, total=False):
    """Arguments for file"""
    take: int
    skip: int
    order_by: Union['categoryOrderByInput', List['categoryOrderByInput']]
    where: 'categoryWhereInput'
    cursor: 'categoryWhereUniqueInput'
    distinct: List['categoryScalarFieldKeys']
    include: 'categoryIncludeFromcategoryRecursive4'


class FindManycategoryArgsFromfileRecursive4(TypedDict, total=False):
    """Arguments for file"""
    take: int
    skip: int
    order_by: Union['categoryOrderByInput', List['categoryOrderByInput']]
    where: 'categoryWhereInput'
    cursor: 'categoryWhereUniqueInput'
    distinct: List['categoryScalarFieldKeys']
    
    

class category_to_articleIncludeFromfile(TypedDict, total=False):
    """Relational arguments for file"""
    article: Union[bool, 'articleArgsFromfileRecursive1']
    category: Union[bool, 'categoryArgsFromfileRecursive1']


class category_to_articleIncludeFromfileRecursive1(TypedDict, total=False):
    """Relational arguments for file"""
    article: Union[bool, 'articleArgsFromfileRecursive2']
    category: Union[bool, 'categoryArgsFromfileRecursive2']


class category_to_articleIncludeFromfileRecursive2(TypedDict, total=False):
    """Relational arguments for file"""
    article: Union[bool, 'articleArgsFromfileRecursive3']
    category: Union[bool, 'categoryArgsFromfileRecursive3']


class category_to_articleIncludeFromfileRecursive3(TypedDict, total=False):
    """Relational arguments for file"""
    article: Union[bool, 'articleArgsFromfileRecursive4']
    category: Union[bool, 'categoryArgsFromfileRecursive4']


class category_to_articleIncludeFromfileRecursive4(TypedDict, total=False):
    """Relational arguments for file"""

    

class category_to_articleArgsFromfile(TypedDict, total=False):
    """Arguments for file"""
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive1'


class category_to_articleArgsFromfileRecursive1(TypedDict, total=False):
    """Arguments for file"""
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive2'


class category_to_articleArgsFromfileRecursive2(TypedDict, total=False):
    """Arguments for file"""
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive3'


class category_to_articleArgsFromfileRecursive3(TypedDict, total=False):
    """Arguments for file"""
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive4'


class category_to_articleArgsFromfileRecursive4(TypedDict, total=False):
    """Arguments for file"""
    
    

class FindManycategory_to_articleArgsFromfile(TypedDict, total=False):
    """Arguments for file"""
    take: int
    skip: int
    order_by: Union['category_to_articleOrderByInput', List['category_to_articleOrderByInput']]
    where: 'category_to_articleWhereInput'
    cursor: 'category_to_articleWhereUniqueInput'
    distinct: List['category_to_articleScalarFieldKeys']
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive1'


class FindManycategory_to_articleArgsFromfileRecursive1(TypedDict, total=False):
    """Arguments for file"""
    take: int
    skip: int
    order_by: Union['category_to_articleOrderByInput', List['category_to_articleOrderByInput']]
    where: 'category_to_articleWhereInput'
    cursor: 'category_to_articleWhereUniqueInput'
    distinct: List['category_to_articleScalarFieldKeys']
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive2'


class FindManycategory_to_articleArgsFromfileRecursive2(TypedDict, total=False):
    """Arguments for file"""
    take: int
    skip: int
    order_by: Union['category_to_articleOrderByInput', List['category_to_articleOrderByInput']]
    where: 'category_to_articleWhereInput'
    cursor: 'category_to_articleWhereUniqueInput'
    distinct: List['category_to_articleScalarFieldKeys']
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive3'


class FindManycategory_to_articleArgsFromfileRecursive3(TypedDict, total=False):
    """Arguments for file"""
    take: int
    skip: int
    order_by: Union['category_to_articleOrderByInput', List['category_to_articleOrderByInput']]
    where: 'category_to_articleWhereInput'
    cursor: 'category_to_articleWhereUniqueInput'
    distinct: List['category_to_articleScalarFieldKeys']
    include: 'category_to_articleIncludeFromcategory_to_articleRecursive4'


class FindManycategory_to_articleArgsFromfileRecursive4(TypedDict, total=False):
    """Arguments for file"""
    take: int
    skip: int
    order_by: Union['category_to_articleOrderByInput', List['category_to_articleOrderByInput']]
    where: 'category_to_articleWhereInput'
    cursor: 'category_to_articleWhereUniqueInput'
    distinct: List['category_to_articleScalarFieldKeys']
    
    

class commentIncludeFromfile(TypedDict, total=False):
    """Relational arguments for file"""
    article: Union[bool, 'articleArgsFromfileRecursive1']
    user: Union[bool, 'userArgsFromfileRecursive1']


class commentIncludeFromfileRecursive1(TypedDict, total=False):
    """Relational arguments for file"""
    article: Union[bool, 'articleArgsFromfileRecursive2']
    user: Union[bool, 'userArgsFromfileRecursive2']


class commentIncludeFromfileRecursive2(TypedDict, total=False):
    """Relational arguments for file"""
    article: Union[bool, 'articleArgsFromfileRecursive3']
    user: Union[bool, 'userArgsFromfileRecursive3']


class commentIncludeFromfileRecursive3(TypedDict, total=False):
    """Relational arguments for file"""
    article: Union[bool, 'articleArgsFromfileRecursive4']
    user: Union[bool, 'userArgsFromfileRecursive4']


class commentIncludeFromfileRecursive4(TypedDict, total=False):
    """Relational arguments for file"""

    

class commentArgsFromfile(TypedDict, total=False):
    """Arguments for file"""
    include: 'commentIncludeFromcommentRecursive1'


class commentArgsFromfileRecursive1(TypedDict, total=False):
    """Arguments for file"""
    include: 'commentIncludeFromcommentRecursive2'


class commentArgsFromfileRecursive2(TypedDict, total=False):
    """Arguments for file"""
    include: 'commentIncludeFromcommentRecursive3'


class commentArgsFromfileRecursive3(TypedDict, total=False):
    """Arguments for file"""
    include: 'commentIncludeFromcommentRecursive4'


class commentArgsFromfileRecursive4(TypedDict, total=False):
    """Arguments for file"""
    
    

class FindManycommentArgsFromfile(TypedDict, total=False):
    """Arguments for file"""
    take: int
    skip: int
    order_by: Union['commentOrderByInput', List['commentOrderByInput']]
    where: 'commentWhereInput'
    cursor: 'commentWhereUniqueInput'
    distinct: List['commentScalarFieldKeys']
    include: 'commentIncludeFromcommentRecursive1'


class FindManycommentArgsFromfileRecursive1(TypedDict, total=False):
    """Arguments for file"""
    take: int
    skip: int
    order_by: Union['commentOrderByInput', List['commentOrderByInput']]
    where: 'commentWhereInput'
    cursor: 'commentWhereUniqueInput'
    distinct: List['commentScalarFieldKeys']
    include: 'commentIncludeFromcommentRecursive2'


class FindManycommentArgsFromfileRecursive2(TypedDict, total=False):
    """Arguments for file"""
    take: int
    skip: int
    order_by: Union['commentOrderByInput', List['commentOrderByInput']]
    where: 'commentWhereInput'
    cursor: 'commentWhereUniqueInput'
    distinct: List['commentScalarFieldKeys']
    include: 'commentIncludeFromcommentRecursive3'


class FindManycommentArgsFromfileRecursive3(TypedDict, total=False):
    """Arguments for file"""
    take: int
    skip: int
    order_by: Union['commentOrderByInput', List['commentOrderByInput']]
    where: 'commentWhereInput'
    cursor: 'commentWhereUniqueInput'
    distinct: List['commentScalarFieldKeys']
    include: 'commentIncludeFromcommentRecursive4'


class FindManycommentArgsFromfileRecursive4(TypedDict, total=False):
    """Arguments for file"""
    take: int
    skip: int
    order_by: Union['commentOrderByInput', List['commentOrderByInput']]
    where: 'commentWhereInput'
    cursor: 'commentWhereUniqueInput'
    distinct: List['commentScalarFieldKeys']
    
    

class likeIncludeFromfile(TypedDict, total=False):
    """Relational arguments for file"""
    article: Union[bool, 'articleArgsFromfileRecursive1']
    user: Union[bool, 'userArgsFromfileRecursive1']


class likeIncludeFromfileRecursive1(TypedDict, total=False):
    """Relational arguments for file"""
    article: Union[bool, 'articleArgsFromfileRecursive2']
    user: Union[bool, 'userArgsFromfileRecursive2']


class likeIncludeFromfileRecursive2(TypedDict, total=False):
    """Relational arguments for file"""
    article: Union[bool, 'articleArgsFromfileRecursive3']
    user: Union[bool, 'userArgsFromfileRecursive3']


class likeIncludeFromfileRecursive3(TypedDict, total=False):
    """Relational arguments for file"""
    article: Union[bool, 'articleArgsFromfileRecursive4']
    user: Union[bool, 'userArgsFromfileRecursive4']


class likeIncludeFromfileRecursive4(TypedDict, total=False):
    """Relational arguments for file"""

    

class likeArgsFromfile(TypedDict, total=False):
    """Arguments for file"""
    include: 'likeIncludeFromlikeRecursive1'


class likeArgsFromfileRecursive1(TypedDict, total=False):
    """Arguments for file"""
    include: 'likeIncludeFromlikeRecursive2'


class likeArgsFromfileRecursive2(TypedDict, total=False):
    """Arguments for file"""
    include: 'likeIncludeFromlikeRecursive3'


class likeArgsFromfileRecursive3(TypedDict, total=False):
    """Arguments for file"""
    include: 'likeIncludeFromlikeRecursive4'


class likeArgsFromfileRecursive4(TypedDict, total=False):
    """Arguments for file"""
    
    

class FindManylikeArgsFromfile(TypedDict, total=False):
    """Arguments for file"""
    take: int
    skip: int
    order_by: Union['likeOrderByInput', List['likeOrderByInput']]
    where: 'likeWhereInput'
    cursor: 'likeWhereUniqueInput'
    distinct: List['likeScalarFieldKeys']
    include: 'likeIncludeFromlikeRecursive1'


class FindManylikeArgsFromfileRecursive1(TypedDict, total=False):
    """Arguments for file"""
    take: int
    skip: int
    order_by: Union['likeOrderByInput', List['likeOrderByInput']]
    where: 'likeWhereInput'
    cursor: 'likeWhereUniqueInput'
    distinct: List['likeScalarFieldKeys']
    include: 'likeIncludeFromlikeRecursive2'


class FindManylikeArgsFromfileRecursive2(TypedDict, total=False):
    """Arguments for file"""
    take: int
    skip: int
    order_by: Union['likeOrderByInput', List['likeOrderByInput']]
    where: 'likeWhereInput'
    cursor: 'likeWhereUniqueInput'
    distinct: List['likeScalarFieldKeys']
    include: 'likeIncludeFromlikeRecursive3'


class FindManylikeArgsFromfileRecursive3(TypedDict, total=False):
    """Arguments for file"""
    take: int
    skip: int
    order_by: Union['likeOrderByInput', List['likeOrderByInput']]
    where: 'likeWhereInput'
    cursor: 'likeWhereUniqueInput'
    distinct: List['likeScalarFieldKeys']
    include: 'likeIncludeFromlikeRecursive4'


class FindManylikeArgsFromfileRecursive4(TypedDict, total=False):
    """Arguments for file"""
    take: int
    skip: int
    order_by: Union['likeOrderByInput', List['likeOrderByInput']]
    where: 'likeWhereInput'
    cursor: 'likeWhereUniqueInput'
    distinct: List['likeScalarFieldKeys']
    
    

class fileIncludeFromfile(TypedDict, total=False):
    """Relational arguments for file"""
    article: Union[bool, 'articleArgsFromfileRecursive1']


class fileIncludeFromfileRecursive1(TypedDict, total=False):
    """Relational arguments for file"""
    article: Union[bool, 'articleArgsFromfileRecursive2']


class fileIncludeFromfileRecursive2(TypedDict, total=False):
    """Relational arguments for file"""
    article: Union[bool, 'articleArgsFromfileRecursive3']


class fileIncludeFromfileRecursive3(TypedDict, total=False):
    """Relational arguments for file"""
    article: Union[bool, 'articleArgsFromfileRecursive4']


class fileIncludeFromfileRecursive4(TypedDict, total=False):
    """Relational arguments for file"""

    

class fileArgsFromfile(TypedDict, total=False):
    """Arguments for file"""
    include: 'fileIncludeFromfileRecursive1'


class fileArgsFromfileRecursive1(TypedDict, total=False):
    """Arguments for file"""
    include: 'fileIncludeFromfileRecursive2'


class fileArgsFromfileRecursive2(TypedDict, total=False):
    """Arguments for file"""
    include: 'fileIncludeFromfileRecursive3'


class fileArgsFromfileRecursive3(TypedDict, total=False):
    """Arguments for file"""
    include: 'fileIncludeFromfileRecursive4'


class fileArgsFromfileRecursive4(TypedDict, total=False):
    """Arguments for file"""
    
    

class FindManyfileArgsFromfile(TypedDict, total=False):
    """Arguments for file"""
    take: int
    skip: int
    order_by: Union['fileOrderByInput', List['fileOrderByInput']]
    where: 'fileWhereInput'
    cursor: 'fileWhereUniqueInput'
    distinct: List['fileScalarFieldKeys']
    include: 'fileIncludeFromfileRecursive1'


class FindManyfileArgsFromfileRecursive1(TypedDict, total=False):
    """Arguments for file"""
    take: int
    skip: int
    order_by: Union['fileOrderByInput', List['fileOrderByInput']]
    where: 'fileWhereInput'
    cursor: 'fileWhereUniqueInput'
    distinct: List['fileScalarFieldKeys']
    include: 'fileIncludeFromfileRecursive2'


class FindManyfileArgsFromfileRecursive2(TypedDict, total=False):
    """Arguments for file"""
    take: int
    skip: int
    order_by: Union['fileOrderByInput', List['fileOrderByInput']]
    where: 'fileWhereInput'
    cursor: 'fileWhereUniqueInput'
    distinct: List['fileScalarFieldKeys']
    include: 'fileIncludeFromfileRecursive3'


class FindManyfileArgsFromfileRecursive3(TypedDict, total=False):
    """Arguments for file"""
    take: int
    skip: int
    order_by: Union['fileOrderByInput', List['fileOrderByInput']]
    where: 'fileWhereInput'
    cursor: 'fileWhereUniqueInput'
    distinct: List['fileScalarFieldKeys']
    include: 'fileIncludeFromfileRecursive4'


class FindManyfileArgsFromfileRecursive4(TypedDict, total=False):
    """Arguments for file"""
    take: int
    skip: int
    order_by: Union['fileOrderByInput', List['fileOrderByInput']]
    where: 'fileWhereInput'
    cursor: 'fileWhereUniqueInput'
    distinct: List['fileScalarFieldKeys']
    


FindManyfileArgs = FindManyfileArgsFromfile
FindFirstfileArgs = FindManyfileArgsFromfile


    

class fileWhereInput(TypedDict, total=False):
    """file arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    path: Union[_str, 'types.StringFilter']
    filename: Union[_str, 'types.StringFilter']
    mimetype: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    article_id: Union[_int, 'types.IntFilter']
    article: 'articleRelationFilter'

    # should be noted that AND and NOT should be Union['fileWhereInputRecursive1', List['fileWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['fileWhereInputRecursive1']
    OR: List['fileWhereInputRecursive1']
    NOT: List['fileWhereInputRecursive1']


class fileWhereInputRecursive1(TypedDict, total=False):
    """file arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    path: Union[_str, 'types.StringFilter']
    filename: Union[_str, 'types.StringFilter']
    mimetype: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    article_id: Union[_int, 'types.IntFilter']
    article: 'articleRelationFilter'

    # should be noted that AND and NOT should be Union['fileWhereInputRecursive2', List['fileWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['fileWhereInputRecursive2']
    OR: List['fileWhereInputRecursive2']
    NOT: List['fileWhereInputRecursive2']


class fileWhereInputRecursive2(TypedDict, total=False):
    """file arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    path: Union[_str, 'types.StringFilter']
    filename: Union[_str, 'types.StringFilter']
    mimetype: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    article_id: Union[_int, 'types.IntFilter']
    article: 'articleRelationFilter'

    # should be noted that AND and NOT should be Union['fileWhereInputRecursive3', List['fileWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['fileWhereInputRecursive3']
    OR: List['fileWhereInputRecursive3']
    NOT: List['fileWhereInputRecursive3']


class fileWhereInputRecursive3(TypedDict, total=False):
    """file arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    path: Union[_str, 'types.StringFilter']
    filename: Union[_str, 'types.StringFilter']
    mimetype: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    article_id: Union[_int, 'types.IntFilter']
    article: 'articleRelationFilter'

    # should be noted that AND and NOT should be Union['fileWhereInputRecursive4', List['fileWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['fileWhereInputRecursive4']
    OR: List['fileWhereInputRecursive4']
    NOT: List['fileWhereInputRecursive4']


class fileWhereInputRecursive4(TypedDict, total=False):
    """file arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    path: Union[_str, 'types.StringFilter']
    filename: Union[_str, 'types.StringFilter']
    mimetype: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeFilter']
    article_id: Union[_int, 'types.IntFilter']
    article: 'articleRelationFilter'



# aggregate file types


    

class fileScalarWhereWithAggregatesInput(TypedDict, total=False):
    """file arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    path: Union[_str, 'types.StringWithAggregatesFilter']
    filename: Union[_str, 'types.StringWithAggregatesFilter']
    mimetype: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    article_id: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['fileScalarWhereWithAggregatesInputRecursive1']
    OR: List['fileScalarWhereWithAggregatesInputRecursive1']
    NOT: List['fileScalarWhereWithAggregatesInputRecursive1']


class fileScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """file arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    path: Union[_str, 'types.StringWithAggregatesFilter']
    filename: Union[_str, 'types.StringWithAggregatesFilter']
    mimetype: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    article_id: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['fileScalarWhereWithAggregatesInputRecursive2']
    OR: List['fileScalarWhereWithAggregatesInputRecursive2']
    NOT: List['fileScalarWhereWithAggregatesInputRecursive2']


class fileScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """file arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    path: Union[_str, 'types.StringWithAggregatesFilter']
    filename: Union[_str, 'types.StringWithAggregatesFilter']
    mimetype: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    article_id: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['fileScalarWhereWithAggregatesInputRecursive3']
    OR: List['fileScalarWhereWithAggregatesInputRecursive3']
    NOT: List['fileScalarWhereWithAggregatesInputRecursive3']


class fileScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """file arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    path: Union[_str, 'types.StringWithAggregatesFilter']
    filename: Union[_str, 'types.StringWithAggregatesFilter']
    mimetype: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    article_id: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['fileScalarWhereWithAggregatesInputRecursive4']
    OR: List['fileScalarWhereWithAggregatesInputRecursive4']
    NOT: List['fileScalarWhereWithAggregatesInputRecursive4']


class fileScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """file arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    path: Union[_str, 'types.StringWithAggregatesFilter']
    filename: Union[_str, 'types.StringWithAggregatesFilter']
    mimetype: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updated_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    article_id: Union[_int, 'types.IntWithAggregatesFilter']



class fileGroupByOutput(TypedDict, total=False):
    id: _int
    path: _str
    filename: _str
    mimetype: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    article_id: _int
    _sum: 'fileSumAggregateOutput'
    _avg: 'fileAvgAggregateOutput'
    _min: 'fileMinAggregateOutput'
    _max: 'fileMaxAggregateOutput'
    _count: 'fileCountAggregateOutput'


class fileAvgAggregateOutput(TypedDict, total=False):
    """file output for aggregating averages"""
    id: float
    article_id: float


class fileSumAggregateOutput(TypedDict, total=False):
    """file output for aggregating sums"""
    id: _int
    article_id: _int


class fileScalarAggregateOutput(TypedDict, total=False):
    """file output including scalar fields"""
    id: _int
    path: _str
    filename: _str
    mimetype: _str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    article_id: _int


fileMinAggregateOutput = fileScalarAggregateOutput
fileMaxAggregateOutput = fileScalarAggregateOutput


class fileMaxAggregateInput(TypedDict, total=False):
    """file input for aggregating by max"""
    id: bool
    path: bool
    filename: bool
    mimetype: bool
    created_at: bool
    updated_at: bool
    article_id: bool


class fileMinAggregateInput(TypedDict, total=False):
    """file input for aggregating by min"""
    id: bool
    path: bool
    filename: bool
    mimetype: bool
    created_at: bool
    updated_at: bool
    article_id: bool


class fileNumberAggregateInput(TypedDict, total=False):
    """file input for aggregating numbers"""
    id: bool
    article_id: bool


fileAvgAggregateInput = fileNumberAggregateInput
fileSumAggregateInput = fileNumberAggregateInput


fileCountAggregateInput = TypedDict(
    'fileCountAggregateInput',
    {
        'id': bool,
        'path': bool,
        'filename': bool,
        'mimetype': bool,
        'created_at': bool,
        'updated_at': bool,
        'article_id': bool,
        '_all': bool,
    },
    total=False,
)

fileCountAggregateOutput = TypedDict(
    'fileCountAggregateOutput',
    {
        'id': int,
        'path': int,
        'filename': int,
        'mimetype': int,
        'created_at': int,
        'updated_at': int,
        'article_id': int,
        '_all': int,
    },
    total=False,
)


fileKeys = Literal[
    'id',
    'path',
    'filename',
    'mimetype',
    'created_at',
    'updated_at',
    'article_id',
    'article',
]
fileScalarFieldKeys = Literal[
    'id',
    'path',
    'filename',
    'mimetype',
    'created_at',
    'updated_at',
    'article_id',
]
fileScalarFieldKeysT = TypeVar('fileScalarFieldKeysT', bound=fileScalarFieldKeys)

fileRelationalFieldKeys = Literal[
        'article',
    ]



# we have to import ourselves as types can be namespaced to types
from . import types, enums, models, fields